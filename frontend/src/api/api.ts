// tslint:disable
/**
 * server
 * SAFRSAPI
 *
 * The version of the OpenAPI document: 0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import { Configuration } from './configuration'
import axios, { AxiosInstance, AxiosPromise } from 'axios'
import { cacheAdapterEnhancer, throttleAdapterEnhancer } from 'axios-extensions'
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, BaseAPI, RequestArgs, RequiredError } from './base'

// create new axios instance
const globalAxios = axios.create({
  baseURL: BASE_PATH,
  headers: { 'Cache-Control': 'no-cache' },
  // cache will be enabled by default
  adapter: throttleAdapterEnhancer(cacheAdapterEnhancer(axios.defaults.adapter)),
})

/**
 *
 * @export
 * @interface ErrorGetColl
 */
export interface ErrorGetColl {
  /**
   *
   * @type {string}
   * @memberof ErrorGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface ErrorPatchInst
 */
export interface ErrorPatchInst {
  /**
   *
   * @type {string}
   * @memberof ErrorPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface ErrorPostInst1
 */
export interface ErrorPostInst1 {
  /**
   *
   * @type {string}
   * @memberof ErrorPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface ErrorTestCaseRelationship
 */
export interface ErrorTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof ErrorTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface ErrorTestCaseRelationship1
 */
export interface ErrorTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof ErrorTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface FailureGetColl
 */
export interface FailureGetColl {
  /**
   *
   * @type {string}
   * @memberof FailureGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface FailurePatchInst
 */
export interface FailurePatchInst {
  /**
   *
   * @type {string}
   * @memberof FailurePatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface FailurePostInst1
 */
export interface FailurePostInst1 {
  /**
   *
   * @type {string}
   * @memberof FailurePostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface FailureTestCaseRelationship
 */
export interface FailureTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof FailureTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface FailureTestCaseRelationship1
 */
export interface FailureTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof FailureTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyErrorGetColl
 */
export interface FlakyErrorGetColl {
  /**
   *
   * @type {string}
   * @memberof FlakyErrorGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyErrorPatchInst
 */
export interface FlakyErrorPatchInst {
  /**
   *
   * @type {string}
   * @memberof FlakyErrorPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyErrorPostInst1
 */
export interface FlakyErrorPostInst1 {
  /**
   *
   * @type {string}
   * @memberof FlakyErrorPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyErrorTestCaseRelationship
 */
export interface FlakyErrorTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof FlakyErrorTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyErrorTestCaseRelationship1
 */
export interface FlakyErrorTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof FlakyErrorTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyFailureGetColl
 */
export interface FlakyFailureGetColl {
  /**
   *
   * @type {string}
   * @memberof FlakyFailureGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyFailurePatchInst
 */
export interface FlakyFailurePatchInst {
  /**
   *
   * @type {string}
   * @memberof FlakyFailurePatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyFailurePostInst1
 */
export interface FlakyFailurePostInst1 {
  /**
   *
   * @type {string}
   * @memberof FlakyFailurePostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyFailureTestCaseRelationship
 */
export interface FlakyFailureTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof FlakyFailureTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface FlakyFailureTestCaseRelationship1
 */
export interface FlakyFailureTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof FlakyFailureTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunErrorGetColl
 */
export interface RerunErrorGetColl {
  /**
   *
   * @type {string}
   * @memberof RerunErrorGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunErrorPatchInst
 */
export interface RerunErrorPatchInst {
  /**
   *
   * @type {string}
   * @memberof RerunErrorPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunErrorPostInst1
 */
export interface RerunErrorPostInst1 {
  /**
   *
   * @type {string}
   * @memberof RerunErrorPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunErrorTestCaseRelationship
 */
export interface RerunErrorTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof RerunErrorTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunErrorTestCaseRelationship1
 */
export interface RerunErrorTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof RerunErrorTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunFailureGetColl
 */
export interface RerunFailureGetColl {
  /**
   *
   * @type {string}
   * @memberof RerunFailureGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunFailurePatchInst
 */
export interface RerunFailurePatchInst {
  /**
   *
   * @type {string}
   * @memberof RerunFailurePatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunFailurePostInst1
 */
export interface RerunFailurePostInst1 {
  /**
   *
   * @type {string}
   * @memberof RerunFailurePostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunFailureTestCaseRelationship
 */
export interface RerunFailureTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof RerunFailureTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface RerunFailureTestCaseRelationship1
 */
export interface RerunFailureTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof RerunFailureTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface SkippedGetColl
 */
export interface SkippedGetColl {
  /**
   *
   * @type {string}
   * @memberof SkippedGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface SkippedPatchInst
 */
export interface SkippedPatchInst {
  /**
   *
   * @type {string}
   * @memberof SkippedPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface SkippedPostInst1
 */
export interface SkippedPostInst1 {
  /**
   *
   * @type {string}
   * @memberof SkippedPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface SkippedTestCaseRelationship
 */
export interface SkippedTestCaseRelationship {
  /**
   *
   * @type {string}
   * @memberof SkippedTestCaseRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface SkippedTestCaseRelationship1
 */
export interface SkippedTestCaseRelationship1 {
  /**
   *
   * @type {string}
   * @memberof SkippedTestCaseRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseErrorsRelationship
 */
export interface TestCaseErrorsRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseErrorsRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseErrorsRelationship1
 */
export interface TestCaseErrorsRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseErrorsRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseFailuresRelationship
 */
export interface TestCaseFailuresRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseFailuresRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseFailuresRelationship1
 */
export interface TestCaseFailuresRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseFailuresRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseFlakyErrorsRelationship
 */
export interface TestCaseFlakyErrorsRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseFlakyErrorsRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseFlakyErrorsRelationship1
 */
export interface TestCaseFlakyErrorsRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseFlakyErrorsRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseFlakyFailuresRelationship
 */
export interface TestCaseFlakyFailuresRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseFlakyFailuresRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseFlakyFailuresRelationship1
 */
export interface TestCaseFlakyFailuresRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseFlakyFailuresRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseGetColl
 */
export interface TestCaseGetColl {
  /**
   *
   * @type {string}
   * @memberof TestCaseGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCasePatchInst
 */
export interface TestCasePatchInst {
  /**
   *
   * @type {string}
   * @memberof TestCasePatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCasePostInst1
 */
export interface TestCasePostInst1 {
  /**
   *
   * @type {string}
   * @memberof TestCasePostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseRerunErrorsRelationship
 */
export interface TestCaseRerunErrorsRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseRerunErrorsRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseRerunErrorsRelationship1
 */
export interface TestCaseRerunErrorsRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseRerunErrorsRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseRerunFailuresRelationship
 */
export interface TestCaseRerunFailuresRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseRerunFailuresRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseRerunFailuresRelationship1
 */
export interface TestCaseRerunFailuresRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseRerunFailuresRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseSkippedsRelationship
 */
export interface TestCaseSkippedsRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseSkippedsRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseSkippedsRelationship1
 */
export interface TestCaseSkippedsRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseSkippedsRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticGetColl
 */
export interface TestCaseStaticGetColl {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticPatchInst
 */
export interface TestCaseStaticPatchInst {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticPostInst1
 */
export interface TestCaseStaticPostInst1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticTestCasesRelationship
 */
export interface TestCaseStaticTestCasesRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticTestCasesRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticTestCasesRelationship1
 */
export interface TestCaseStaticTestCasesRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticTestCasesRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticTestSuiteStaticRelationship
 */
export interface TestCaseStaticTestSuiteStaticRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticTestSuiteStaticRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseStaticTestSuiteStaticRelationship1
 */
export interface TestCaseStaticTestSuiteStaticRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseStaticTestSuiteStaticRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseTestCaseStaticRelationship
 */
export interface TestCaseTestCaseStaticRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseTestCaseStaticRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseTestCaseStaticRelationship1
 */
export interface TestCaseTestCaseStaticRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseTestCaseStaticRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseTestSuiteRelationship
 */
export interface TestCaseTestSuiteRelationship {
  /**
   *
   * @type {string}
   * @memberof TestCaseTestSuiteRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestCaseTestSuiteRelationship1
 */
export interface TestCaseTestSuiteRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestCaseTestSuiteRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestRunGetColl
 */
export interface TestRunGetColl {
  /**
   *
   * @type {string}
   * @memberof TestRunGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestRunPatchInst
 */
export interface TestRunPatchInst {
  /**
   *
   * @type {string}
   * @memberof TestRunPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestRunPostInst1
 */
export interface TestRunPostInst1 {
  /**
   *
   * @type {string}
   * @memberof TestRunPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestRunTestSuitesRelationship
 */
export interface TestRunTestSuitesRelationship {
  /**
   *
   * @type {string}
   * @memberof TestRunTestSuitesRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestRunTestSuitesRelationship1
 */
export interface TestRunTestSuitesRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestRunTestSuitesRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteGetColl
 */
export interface TestSuiteGetColl {
  /**
   *
   * @type {string}
   * @memberof TestSuiteGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuitePatchInst
 */
export interface TestSuitePatchInst {
  /**
   *
   * @type {string}
   * @memberof TestSuitePatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuitePostInst1
 */
export interface TestSuitePostInst1 {
  /**
   *
   * @type {string}
   * @memberof TestSuitePostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticGetColl
 */
export interface TestSuiteStaticGetColl {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticGetColl
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticPatchInst
 */
export interface TestSuiteStaticPatchInst {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticPatchInst
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticPostInst1
 */
export interface TestSuiteStaticPostInst1 {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticPostInst1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticTestCaseStaticsRelationship
 */
export interface TestSuiteStaticTestCaseStaticsRelationship {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticTestCaseStaticsRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticTestCaseStaticsRelationship1
 */
export interface TestSuiteStaticTestCaseStaticsRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticTestCaseStaticsRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticTestSuitesRelationship
 */
export interface TestSuiteStaticTestSuitesRelationship {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticTestSuitesRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteStaticTestSuitesRelationship1
 */
export interface TestSuiteStaticTestSuitesRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestSuiteStaticTestSuitesRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteTestCasesRelationship
 */
export interface TestSuiteTestCasesRelationship {
  /**
   *
   * @type {string}
   * @memberof TestSuiteTestCasesRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteTestCasesRelationship1
 */
export interface TestSuiteTestCasesRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestSuiteTestCasesRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteTestRunRelationship
 */
export interface TestSuiteTestRunRelationship {
  /**
   *
   * @type {string}
   * @memberof TestSuiteTestRunRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteTestRunRelationship1
 */
export interface TestSuiteTestRunRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestSuiteTestRunRelationship1
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteTestSuiteStaticRelationship
 */
export interface TestSuiteTestSuiteStaticRelationship {
  /**
   *
   * @type {string}
   * @memberof TestSuiteTestSuiteStaticRelationship
   */
  data?: string
}

/**
 *
 * @export
 * @interface TestSuiteTestSuiteStaticRelationship1
 */
export interface TestSuiteTestSuiteStaticRelationship1 {
  /**
   *
   * @type {string}
   * @memberof TestSuiteTestSuiteStaticRelationship1
   */
  data?: string
}

/**
 * ErrorApi - axios parameter creator
 * @export
 */
export const ErrorApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the Error test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase0: async (
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling addTestCaseitemstotestcase0.'
        )
      }
      // verify required parameter 'errorTestCaseBody' is not null or undefined
      if (errorTestCaseBody === null || errorTestCaseBody === undefined) {
        throw new RequiredError(
          'errorTestCaseBody',
          'Required parameter errorTestCaseBody was null or undefined when calling addTestCaseitemstotestcase0.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/test_case`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      // @ts-ignore
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof errorTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(errorTestCaseBody !== undefined ? errorTestCaseBody : {})
        : errorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Error
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {ErrorPostInst1} pOSTBody Error attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createError0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: ErrorPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createError0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createError0.'
        )
      }
      const localVarPath = `/Error/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete Error from Error
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteErrorfromError0: async (
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling deleteErrorfromError0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteErrorfromError0.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the Error test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase0: async (
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling deleteTestCasefromtestcase0.'
        )
      }
      // verify required parameter 'errorTestCaseBody' is not null or undefined
      if (errorTestCaseBody === null || errorTestCaseBody === undefined) {
        throw new RequiredError(
          'errorTestCaseBody',
          'Required parameter errorTestCaseBody was null or undefined when calling deleteTestCasefromtestcase0.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/test_case`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof errorTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(errorTestCaseBody !== undefined ? errorTestCaseBody : {})
        : errorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Error from Error
     * @summary Retrieve a collection of Error objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Error filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveErrorinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveErrorinstance0.'
        )
      }
      const localVarPath = `/Error/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsError !== undefined) {
        localVarQueryParameter['fields[Error]'] = fieldsError
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Error from Error
     * @summary Retrieve Error instance
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveErrorinstance1: async (
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsError?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling retrieveErrorinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveErrorinstance1.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsError !== undefined) {
        localVarQueryParameter['fields[Error]'] = fieldsError
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the Error test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} errorId Error item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase0: async (
      errorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling retrieveTestCasefromtestcase0.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/test_case`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update Error attributes
     * @summary Update Error
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {ErrorPatchInst} pATCHBody Error attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateError0: async (
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: ErrorPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling updateError0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateError0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateError0.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the Error test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase0: async (
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'errorId' is not null or undefined
      if (errorId === null || errorId === undefined) {
        throw new RequiredError(
          'errorId',
          'Required parameter errorId was null or undefined when calling updatetestcase0.'
        )
      }
      // verify required parameter 'errorTestCaseBody' is not null or undefined
      if (errorTestCaseBody === null || errorTestCaseBody === undefined) {
        throw new RequiredError(
          'errorTestCaseBody',
          'Required parameter errorTestCaseBody was null or undefined when calling updatetestcase0.'
        )
      }
      const localVarPath = `/Error/{ErrorId}/test_case`.replace(`{${'ErrorId'}}`, encodeURIComponent(String(errorId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof errorTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(errorTestCaseBody !== undefined ? errorTestCaseBody : {})
        : errorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ErrorApi - functional programming interface
 * @export
 */
export const ErrorApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the Error test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase0(
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).addTestCaseitemstotestcase0(
        errorId,
        errorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Error
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {ErrorPostInst1} pOSTBody Error attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createError0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: ErrorPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).createError0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete Error from Error
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteErrorfromError0(
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).deleteErrorfromError0(
        errorId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the Error test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase0(
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).deleteTestCasefromtestcase0(
        errorId,
        errorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Error from Error
     * @summary Retrieve a collection of Error objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Error filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveErrorinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorGetColl>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).retrieveErrorinstance0(
        contentType,
        include,
        fieldsError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Error from Error
     * @summary Retrieve Error instance
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveErrorinstance1(
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsError?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).retrieveErrorinstance1(
        errorId,
        contentType,
        include,
        fieldsError,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the Error test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} errorId Error item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase0(
      errorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase0(
        errorId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update Error attributes
     * @summary Update Error
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {ErrorPatchInst} pATCHBody Error attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateError0(
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: ErrorPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).updateError0(
        errorId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the Error test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase0(
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await ErrorApiAxiosParamCreator(configuration).updatetestcase0(
        errorId,
        errorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ErrorApi - factory interface
 * @export
 */
export const ErrorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestCase items to the Error test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase0(
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .addTestCaseitemstotestcase0(errorId, errorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Error
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {ErrorPostInst1} pOSTBody Error attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createError0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: ErrorPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .createError0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete Error from Error
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteErrorfromError0(
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .deleteErrorfromError0(errorId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the Error test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase0(
      errorId: string,
      errorTestCaseBody: ErrorTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .deleteTestCasefromtestcase0(errorId, errorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Error from Error
     * @summary Retrieve a collection of Error objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Error filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveErrorinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<ErrorGetColl> {
      return ErrorApiFp(configuration)
        .retrieveErrorinstance0(
          contentType,
          include,
          fieldsError,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Error from Error
     * @summary Retrieve Error instance
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveErrorinstance1(
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsError?: string,
      options?: any
    ): AxiosPromise<object> {
      return ErrorApiFp(configuration)
        .retrieveErrorinstance1(errorId, contentType, include, fieldsError, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the Error test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} errorId Error item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase0(
      errorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .retrieveTestCasefromtestcase0(
          errorId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update Error attributes
     * @summary Update Error
     * @param {string} errorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {ErrorPatchInst} pATCHBody Error attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateError0(
      errorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: ErrorPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .updateError0(errorId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the Error test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} errorId Error item
     * @param {ErrorTestCaseRelationship} errorTestCaseBody Error.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase0(errorId: string, errorTestCaseBody: ErrorTestCaseRelationship, options?: any): AxiosPromise<void> {
      return ErrorApiFp(configuration)
        .updatetestcase0(errorId, errorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ErrorApi - object-oriented interface
 * @export
 * @class ErrorApi
 * @extends {BaseAPI}
 */
export class ErrorApi extends BaseAPI {
  /**
   * Add TestCase items to the Error test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} errorId Error item
   * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public addTestCaseitemstotestcase0(errorId: string, errorTestCaseBody: ErrorTestCaseRelationship1, options?: any) {
    return ErrorApiFp(this.configuration)
      .addTestCaseitemstotestcase0(errorId, errorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Error
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {ErrorPostInst1} pOSTBody Error attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public createError0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: ErrorPostInst1,
    options?: any
  ) {
    return ErrorApiFp(this.configuration)
      .createError0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete Error from Error
   * @param {string} errorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public deleteErrorfromError0(
    errorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return ErrorApiFp(this.configuration)
      .deleteErrorfromError0(errorId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the Error test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} errorId Error item
   * @param {ErrorTestCaseRelationship1} errorTestCaseBody Error.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public deleteTestCasefromtestcase0(errorId: string, errorTestCaseBody: ErrorTestCaseRelationship1, options?: any) {
    return ErrorApiFp(this.configuration)
      .deleteTestCasefromtestcase0(errorId, errorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Error from Error
   * @summary Retrieve a collection of Error objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] Error relationships to include (csv)
   * @param {string} [fieldsError] Error fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom Error filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public retrieveErrorinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsError?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return ErrorApiFp(this.configuration)
      .retrieveErrorinstance0(
        contentType,
        include,
        fieldsError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Error from Error
   * @summary Retrieve Error instance
   * @param {string} errorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] Error relationships to include (csv)
   * @param {string} [fieldsError] Error fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public retrieveErrorinstance1(
    errorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsError?: string,
    options?: any
  ) {
    return ErrorApiFp(this.configuration)
      .retrieveErrorinstance1(errorId, contentType, include, fieldsError, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the Error test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} errorId Error item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public retrieveTestCasefromtestcase0(
    errorId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return ErrorApiFp(this.configuration)
      .retrieveTestCasefromtestcase0(
        errorId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update Error attributes
   * @summary Update Error
   * @param {string} errorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {ErrorPatchInst} pATCHBody Error attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public updateError0(
    errorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: ErrorPatchInst,
    options?: any
  ) {
    return ErrorApiFp(this.configuration)
      .updateError0(errorId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the Error test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} errorId Error item
   * @param {ErrorTestCaseRelationship} errorTestCaseBody Error.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ErrorApi
   */
  public updatetestcase0(errorId: string, errorTestCaseBody: ErrorTestCaseRelationship, options?: any) {
    return ErrorApiFp(this.configuration)
      .updatetestcase0(errorId, errorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FailureApi - axios parameter creator
 * @export
 */
export const FailureApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the Failure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase1: async (
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling addTestCaseitemstotestcase1.'
        )
      }
      // verify required parameter 'failureTestCaseBody' is not null or undefined
      if (failureTestCaseBody === null || failureTestCaseBody === undefined) {
        throw new RequiredError(
          'failureTestCaseBody',
          'Required parameter failureTestCaseBody was null or undefined when calling addTestCaseitemstotestcase1.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/test_case`.replace(
        `{${'FailureId'}}`,
        encodeURIComponent(String(failureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof failureTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(failureTestCaseBody !== undefined ? failureTestCaseBody : {})
        : failureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Failure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FailurePostInst1} pOSTBody Failure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFailure0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FailurePostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createFailure0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createFailure0.'
        )
      }
      const localVarPath = `/Failure/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete Failure from Failure
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFailurefromFailure0: async (
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling deleteFailurefromFailure0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteFailurefromFailure0.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/`.replace(`{${'FailureId'}}`, encodeURIComponent(String(failureId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the Failure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase1: async (
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling deleteTestCasefromtestcase1.'
        )
      }
      // verify required parameter 'failureTestCaseBody' is not null or undefined
      if (failureTestCaseBody === null || failureTestCaseBody === undefined) {
        throw new RequiredError(
          'failureTestCaseBody',
          'Required parameter failureTestCaseBody was null or undefined when calling deleteTestCasefromtestcase1.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/test_case`.replace(
        `{${'FailureId'}}`,
        encodeURIComponent(String(failureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof failureTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(failureTestCaseBody !== undefined ? failureTestCaseBody : {})
        : failureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Failure from Failure
     * @summary Retrieve a collection of Failure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Failure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFailureinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveFailureinstance0.'
        )
      }
      const localVarPath = `/Failure/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFailure !== undefined) {
        localVarQueryParameter['fields[Failure]'] = fieldsFailure
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Failure from Failure
     * @summary Retrieve Failure instance
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFailureinstance1: async (
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFailure?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling retrieveFailureinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveFailureinstance1.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/`.replace(`{${'FailureId'}}`, encodeURIComponent(String(failureId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFailure !== undefined) {
        localVarQueryParameter['fields[Failure]'] = fieldsFailure
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the Failure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} failureId Failure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase1: async (
      failureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling retrieveTestCasefromtestcase1.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/test_case`.replace(
        `{${'FailureId'}}`,
        encodeURIComponent(String(failureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update Failure attributes
     * @summary Update Failure
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FailurePatchInst} pATCHBody Failure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFailure0: async (
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FailurePatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling updateFailure0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateFailure0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateFailure0.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/`.replace(`{${'FailureId'}}`, encodeURIComponent(String(failureId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the Failure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase1: async (
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'failureId' is not null or undefined
      if (failureId === null || failureId === undefined) {
        throw new RequiredError(
          'failureId',
          'Required parameter failureId was null or undefined when calling updatetestcase1.'
        )
      }
      // verify required parameter 'failureTestCaseBody' is not null or undefined
      if (failureTestCaseBody === null || failureTestCaseBody === undefined) {
        throw new RequiredError(
          'failureTestCaseBody',
          'Required parameter failureTestCaseBody was null or undefined when calling updatetestcase1.'
        )
      }
      const localVarPath = `/Failure/{FailureId}/test_case`.replace(
        `{${'FailureId'}}`,
        encodeURIComponent(String(failureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof failureTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(failureTestCaseBody !== undefined ? failureTestCaseBody : {})
        : failureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FailureApi - functional programming interface
 * @export
 */
export const FailureApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the Failure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase1(
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).addTestCaseitemstotestcase1(
        failureId,
        failureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Failure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FailurePostInst1} pOSTBody Failure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFailure0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FailurePostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).createFailure0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete Failure from Failure
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFailurefromFailure0(
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).deleteFailurefromFailure0(
        failureId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the Failure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase1(
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).deleteTestCasefromtestcase1(
        failureId,
        failureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Failure from Failure
     * @summary Retrieve a collection of Failure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Failure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFailureinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailureGetColl>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).retrieveFailureinstance0(
        contentType,
        include,
        fieldsFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Failure from Failure
     * @summary Retrieve Failure instance
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFailureinstance1(
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFailure?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).retrieveFailureinstance1(
        failureId,
        contentType,
        include,
        fieldsFailure,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the Failure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} failureId Failure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase1(
      failureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase1(
        failureId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update Failure attributes
     * @summary Update Failure
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FailurePatchInst} pATCHBody Failure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFailure0(
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FailurePatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).updateFailure0(
        failureId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the Failure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase1(
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FailureApiAxiosParamCreator(configuration).updatetestcase1(
        failureId,
        failureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * FailureApi - factory interface
 * @export
 */
export const FailureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestCase items to the Failure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase1(
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .addTestCaseitemstotestcase1(failureId, failureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Failure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FailurePostInst1} pOSTBody Failure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFailure0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FailurePostInst1,
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .createFailure0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete Failure from Failure
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFailurefromFailure0(
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .deleteFailurefromFailure0(failureId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the Failure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase1(
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .deleteTestCasefromtestcase1(failureId, failureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Failure from Failure
     * @summary Retrieve a collection of Failure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Failure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFailureinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<FailureGetColl> {
      return FailureApiFp(configuration)
        .retrieveFailureinstance0(
          contentType,
          include,
          fieldsFailure,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Failure from Failure
     * @summary Retrieve Failure instance
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFailureinstance1(
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFailure?: string,
      options?: any
    ): AxiosPromise<object> {
      return FailureApiFp(configuration)
        .retrieveFailureinstance1(failureId, contentType, include, fieldsFailure, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the Failure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} failureId Failure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase1(
      failureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .retrieveTestCasefromtestcase1(
          failureId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update Failure attributes
     * @summary Update Failure
     * @param {string} failureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FailurePatchInst} pATCHBody Failure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFailure0(
      failureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FailurePatchInst,
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .updateFailure0(failureId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the Failure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} failureId Failure item
     * @param {FailureTestCaseRelationship} failureTestCaseBody Failure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase1(
      failureId: string,
      failureTestCaseBody: FailureTestCaseRelationship,
      options?: any
    ): AxiosPromise<void> {
      return FailureApiFp(configuration)
        .updatetestcase1(failureId, failureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FailureApi - object-oriented interface
 * @export
 * @class FailureApi
 * @extends {BaseAPI}
 */
export class FailureApi extends BaseAPI {
  /**
   * Add TestCase items to the Failure test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} failureId Failure item
   * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public addTestCaseitemstotestcase1(
    failureId: string,
    failureTestCaseBody: FailureTestCaseRelationship1,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .addTestCaseitemstotestcase1(failureId, failureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Failure
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {FailurePostInst1} pOSTBody Failure attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public createFailure0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: FailurePostInst1,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .createFailure0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete Failure from Failure
   * @param {string} failureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public deleteFailurefromFailure0(
    failureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .deleteFailurefromFailure0(failureId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the Failure test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} failureId Failure item
   * @param {FailureTestCaseRelationship1} failureTestCaseBody Failure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public deleteTestCasefromtestcase1(
    failureId: string,
    failureTestCaseBody: FailureTestCaseRelationship1,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .deleteTestCasefromtestcase1(failureId, failureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Failure from Failure
   * @summary Retrieve a collection of Failure objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] Failure relationships to include (csv)
   * @param {string} [fieldsFailure] Failure fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom Failure filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public retrieveFailureinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsFailure?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .retrieveFailureinstance0(
        contentType,
        include,
        fieldsFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Failure from Failure
   * @summary Retrieve Failure instance
   * @param {string} failureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] Failure relationships to include (csv)
   * @param {string} [fieldsFailure] Failure fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public retrieveFailureinstance1(
    failureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsFailure?: string,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .retrieveFailureinstance1(failureId, contentType, include, fieldsFailure, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the Failure test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} failureId Failure item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public retrieveTestCasefromtestcase1(
    failureId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .retrieveTestCasefromtestcase1(
        failureId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update Failure attributes
   * @summary Update Failure
   * @param {string} failureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {FailurePatchInst} pATCHBody Failure attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public updateFailure0(
    failureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: FailurePatchInst,
    options?: any
  ) {
    return FailureApiFp(this.configuration)
      .updateFailure0(failureId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the Failure test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} failureId Failure item
   * @param {FailureTestCaseRelationship} failureTestCaseBody Failure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FailureApi
   */
  public updatetestcase1(failureId: string, failureTestCaseBody: FailureTestCaseRelationship, options?: any) {
    return FailureApiFp(this.configuration)
      .updatetestcase1(failureId, failureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FlakyErrorApi - axios parameter creator
 * @export
 */
export const FlakyErrorApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the FlakyError test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase2: async (
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling addTestCaseitemstotestcase2.'
        )
      }
      // verify required parameter 'flakyErrorTestCaseBody' is not null or undefined
      if (flakyErrorTestCaseBody === null || flakyErrorTestCaseBody === undefined) {
        throw new RequiredError(
          'flakyErrorTestCaseBody',
          'Required parameter flakyErrorTestCaseBody was null or undefined when calling addTestCaseitemstotestcase2.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/test_case`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof flakyErrorTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(flakyErrorTestCaseBody !== undefined ? flakyErrorTestCaseBody : {})
        : flakyErrorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create FlakyError
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyErrorPostInst1} pOSTBody FlakyError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFlakyError0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FlakyErrorPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createFlakyError0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createFlakyError0.'
        )
      }
      const localVarPath = `/FlakyError/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete FlakyError from FlakyError
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyErrorfromFlakyError0: async (
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling deleteFlakyErrorfromFlakyError0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteFlakyErrorfromFlakyError0.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the FlakyError test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase2: async (
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling deleteTestCasefromtestcase2.'
        )
      }
      // verify required parameter 'flakyErrorTestCaseBody' is not null or undefined
      if (flakyErrorTestCaseBody === null || flakyErrorTestCaseBody === undefined) {
        throw new RequiredError(
          'flakyErrorTestCaseBody',
          'Required parameter flakyErrorTestCaseBody was null or undefined when calling deleteTestCasefromtestcase2.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/test_case`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof flakyErrorTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(flakyErrorTestCaseBody !== undefined ? flakyErrorTestCaseBody : {})
        : flakyErrorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve FlakyError from FlakyError
     * @summary Retrieve a collection of FlakyError objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyErrorinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveFlakyErrorinstance0.'
        )
      }
      const localVarPath = `/FlakyError/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFlakyError !== undefined) {
        localVarQueryParameter['fields[FlakyError]'] = fieldsFlakyError
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve FlakyError from FlakyError
     * @summary Retrieve FlakyError instance
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyErrorinstance1: async (
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyError?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling retrieveFlakyErrorinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveFlakyErrorinstance1.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFlakyError !== undefined) {
        localVarQueryParameter['fields[FlakyError]'] = fieldsFlakyError
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the FlakyError test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase2: async (
      flakyErrorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling retrieveTestCasefromtestcase2.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/test_case`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update FlakyError attributes
     * @summary Update FlakyError
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyErrorPatchInst} pATCHBody FlakyError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFlakyError0: async (
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FlakyErrorPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling updateFlakyError0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateFlakyError0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateFlakyError0.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the FlakyError test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase2: async (
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyErrorId' is not null or undefined
      if (flakyErrorId === null || flakyErrorId === undefined) {
        throw new RequiredError(
          'flakyErrorId',
          'Required parameter flakyErrorId was null or undefined when calling updatetestcase2.'
        )
      }
      // verify required parameter 'flakyErrorTestCaseBody' is not null or undefined
      if (flakyErrorTestCaseBody === null || flakyErrorTestCaseBody === undefined) {
        throw new RequiredError(
          'flakyErrorTestCaseBody',
          'Required parameter flakyErrorTestCaseBody was null or undefined when calling updatetestcase2.'
        )
      }
      const localVarPath = `/FlakyError/{FlakyErrorId}/test_case`.replace(
        `{${'FlakyErrorId'}}`,
        encodeURIComponent(String(flakyErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof flakyErrorTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(flakyErrorTestCaseBody !== undefined ? flakyErrorTestCaseBody : {})
        : flakyErrorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FlakyErrorApi - functional programming interface
 * @export
 */
export const FlakyErrorApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the FlakyError test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase2(
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).addTestCaseitemstotestcase2(
        flakyErrorId,
        flakyErrorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create FlakyError
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyErrorPostInst1} pOSTBody FlakyError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFlakyError0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FlakyErrorPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).createFlakyError0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete FlakyError from FlakyError
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFlakyErrorfromFlakyError0(
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).deleteFlakyErrorfromFlakyError0(
        flakyErrorId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the FlakyError test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase2(
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).deleteTestCasefromtestcase2(
        flakyErrorId,
        flakyErrorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve FlakyError from FlakyError
     * @summary Retrieve a collection of FlakyError objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFlakyErrorinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlakyErrorGetColl>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).retrieveFlakyErrorinstance0(
        contentType,
        include,
        fieldsFlakyError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve FlakyError from FlakyError
     * @summary Retrieve FlakyError instance
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFlakyErrorinstance1(
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyError?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).retrieveFlakyErrorinstance1(
        flakyErrorId,
        contentType,
        include,
        fieldsFlakyError,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the FlakyError test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase2(
      flakyErrorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase2(
        flakyErrorId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update FlakyError attributes
     * @summary Update FlakyError
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyErrorPatchInst} pATCHBody FlakyError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFlakyError0(
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FlakyErrorPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).updateFlakyError0(
        flakyErrorId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the FlakyError test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase2(
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyErrorApiAxiosParamCreator(configuration).updatetestcase2(
        flakyErrorId,
        flakyErrorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * FlakyErrorApi - factory interface
 * @export
 */
export const FlakyErrorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestCase items to the FlakyError test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase2(
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .addTestCaseitemstotestcase2(flakyErrorId, flakyErrorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create FlakyError
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyErrorPostInst1} pOSTBody FlakyError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFlakyError0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FlakyErrorPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .createFlakyError0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete FlakyError from FlakyError
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyErrorfromFlakyError0(
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .deleteFlakyErrorfromFlakyError0(flakyErrorId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the FlakyError test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase2(
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .deleteTestCasefromtestcase2(flakyErrorId, flakyErrorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve FlakyError from FlakyError
     * @summary Retrieve a collection of FlakyError objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyErrorinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<FlakyErrorGetColl> {
      return FlakyErrorApiFp(configuration)
        .retrieveFlakyErrorinstance0(
          contentType,
          include,
          fieldsFlakyError,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve FlakyError from FlakyError
     * @summary Retrieve FlakyError instance
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyErrorinstance1(
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyError?: string,
      options?: any
    ): AxiosPromise<object> {
      return FlakyErrorApiFp(configuration)
        .retrieveFlakyErrorinstance1(flakyErrorId, contentType, include, fieldsFlakyError, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the FlakyError test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase2(
      flakyErrorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .retrieveTestCasefromtestcase2(
          flakyErrorId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update FlakyError attributes
     * @summary Update FlakyError
     * @param {string} flakyErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyErrorPatchInst} pATCHBody FlakyError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFlakyError0(
      flakyErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FlakyErrorPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .updateFlakyError0(flakyErrorId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the FlakyError test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} flakyErrorId FlakyError item
     * @param {FlakyErrorTestCaseRelationship} flakyErrorTestCaseBody FlakyError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase2(
      flakyErrorId: string,
      flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship,
      options?: any
    ): AxiosPromise<void> {
      return FlakyErrorApiFp(configuration)
        .updatetestcase2(flakyErrorId, flakyErrorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FlakyErrorApi - object-oriented interface
 * @export
 * @class FlakyErrorApi
 * @extends {BaseAPI}
 */
export class FlakyErrorApi extends BaseAPI {
  /**
   * Add TestCase items to the FlakyError test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} flakyErrorId FlakyError item
   * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public addTestCaseitemstotestcase2(
    flakyErrorId: string,
    flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .addTestCaseitemstotestcase2(flakyErrorId, flakyErrorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create FlakyError
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {FlakyErrorPostInst1} pOSTBody FlakyError attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public createFlakyError0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: FlakyErrorPostInst1,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .createFlakyError0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete FlakyError from FlakyError
   * @param {string} flakyErrorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public deleteFlakyErrorfromFlakyError0(
    flakyErrorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .deleteFlakyErrorfromFlakyError0(flakyErrorId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the FlakyError test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} flakyErrorId FlakyError item
   * @param {FlakyErrorTestCaseRelationship1} flakyErrorTestCaseBody FlakyError.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public deleteTestCasefromtestcase2(
    flakyErrorId: string,
    flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship1,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .deleteTestCasefromtestcase2(flakyErrorId, flakyErrorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve FlakyError from FlakyError
   * @summary Retrieve a collection of FlakyError objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] FlakyError relationships to include (csv)
   * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom FlakyError filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public retrieveFlakyErrorinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsFlakyError?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .retrieveFlakyErrorinstance0(
        contentType,
        include,
        fieldsFlakyError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve FlakyError from FlakyError
   * @summary Retrieve FlakyError instance
   * @param {string} flakyErrorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] FlakyError relationships to include (csv)
   * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public retrieveFlakyErrorinstance1(
    flakyErrorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsFlakyError?: string,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .retrieveFlakyErrorinstance1(flakyErrorId, contentType, include, fieldsFlakyError, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the FlakyError test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} flakyErrorId FlakyError item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public retrieveTestCasefromtestcase2(
    flakyErrorId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .retrieveTestCasefromtestcase2(
        flakyErrorId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update FlakyError attributes
   * @summary Update FlakyError
   * @param {string} flakyErrorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {FlakyErrorPatchInst} pATCHBody FlakyError attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public updateFlakyError0(
    flakyErrorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: FlakyErrorPatchInst,
    options?: any
  ) {
    return FlakyErrorApiFp(this.configuration)
      .updateFlakyError0(flakyErrorId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the FlakyError test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} flakyErrorId FlakyError item
   * @param {FlakyErrorTestCaseRelationship} flakyErrorTestCaseBody FlakyError.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyErrorApi
   */
  public updatetestcase2(flakyErrorId: string, flakyErrorTestCaseBody: FlakyErrorTestCaseRelationship, options?: any) {
    return FlakyErrorApiFp(this.configuration)
      .updatetestcase2(flakyErrorId, flakyErrorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FlakyFailureApi - axios parameter creator
 * @export
 */
export const FlakyFailureApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the FlakyFailure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase3: async (
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling addTestCaseitemstotestcase3.'
        )
      }
      // verify required parameter 'flakyFailureTestCaseBody' is not null or undefined
      if (flakyFailureTestCaseBody === null || flakyFailureTestCaseBody === undefined) {
        throw new RequiredError(
          'flakyFailureTestCaseBody',
          'Required parameter flakyFailureTestCaseBody was null or undefined when calling addTestCaseitemstotestcase3.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/test_case`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof flakyFailureTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(flakyFailureTestCaseBody !== undefined ? flakyFailureTestCaseBody : {})
        : flakyFailureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create FlakyFailure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyFailurePostInst1} pOSTBody FlakyFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFlakyFailure0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FlakyFailurePostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createFlakyFailure0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createFlakyFailure0.'
        )
      }
      const localVarPath = `/FlakyFailure/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete FlakyFailure from FlakyFailure
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyFailurefromFlakyFailure0: async (
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling deleteFlakyFailurefromFlakyFailure0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteFlakyFailurefromFlakyFailure0.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the FlakyFailure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase3: async (
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling deleteTestCasefromtestcase3.'
        )
      }
      // verify required parameter 'flakyFailureTestCaseBody' is not null or undefined
      if (flakyFailureTestCaseBody === null || flakyFailureTestCaseBody === undefined) {
        throw new RequiredError(
          'flakyFailureTestCaseBody',
          'Required parameter flakyFailureTestCaseBody was null or undefined when calling deleteTestCasefromtestcase3.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/test_case`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof flakyFailureTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(flakyFailureTestCaseBody !== undefined ? flakyFailureTestCaseBody : {})
        : flakyFailureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve FlakyFailure from FlakyFailure
     * @summary Retrieve a collection of FlakyFailure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyFailureinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveFlakyFailureinstance0.'
        )
      }
      const localVarPath = `/FlakyFailure/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFlakyFailure !== undefined) {
        localVarQueryParameter['fields[FlakyFailure]'] = fieldsFlakyFailure
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve FlakyFailure from FlakyFailure
     * @summary Retrieve FlakyFailure instance
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyFailureinstance1: async (
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyFailure?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling retrieveFlakyFailureinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveFlakyFailureinstance1.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFlakyFailure !== undefined) {
        localVarQueryParameter['fields[FlakyFailure]'] = fieldsFlakyFailure
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the FlakyFailure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase3: async (
      flakyFailureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling retrieveTestCasefromtestcase3.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/test_case`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update FlakyFailure attributes
     * @summary Update FlakyFailure
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyFailurePatchInst} pATCHBody FlakyFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFlakyFailure0: async (
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FlakyFailurePatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling updateFlakyFailure0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateFlakyFailure0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateFlakyFailure0.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the FlakyFailure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase3: async (
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'flakyFailureId' is not null or undefined
      if (flakyFailureId === null || flakyFailureId === undefined) {
        throw new RequiredError(
          'flakyFailureId',
          'Required parameter flakyFailureId was null or undefined when calling updatetestcase3.'
        )
      }
      // verify required parameter 'flakyFailureTestCaseBody' is not null or undefined
      if (flakyFailureTestCaseBody === null || flakyFailureTestCaseBody === undefined) {
        throw new RequiredError(
          'flakyFailureTestCaseBody',
          'Required parameter flakyFailureTestCaseBody was null or undefined when calling updatetestcase3.'
        )
      }
      const localVarPath = `/FlakyFailure/{FlakyFailureId}/test_case`.replace(
        `{${'FlakyFailureId'}}`,
        encodeURIComponent(String(flakyFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof flakyFailureTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(flakyFailureTestCaseBody !== undefined ? flakyFailureTestCaseBody : {})
        : flakyFailureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FlakyFailureApi - functional programming interface
 * @export
 */
export const FlakyFailureApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the FlakyFailure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase3(
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).addTestCaseitemstotestcase3(
        flakyFailureId,
        flakyFailureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create FlakyFailure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyFailurePostInst1} pOSTBody FlakyFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFlakyFailure0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FlakyFailurePostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).createFlakyFailure0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete FlakyFailure from FlakyFailure
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFlakyFailurefromFlakyFailure0(
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(
        configuration
      ).deleteFlakyFailurefromFlakyFailure0(flakyFailureId, contentType, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the FlakyFailure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase3(
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).deleteTestCasefromtestcase3(
        flakyFailureId,
        flakyFailureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve FlakyFailure from FlakyFailure
     * @summary Retrieve a collection of FlakyFailure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFlakyFailureinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlakyFailureGetColl>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).retrieveFlakyFailureinstance0(
        contentType,
        include,
        fieldsFlakyFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve FlakyFailure from FlakyFailure
     * @summary Retrieve FlakyFailure instance
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFlakyFailureinstance1(
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyFailure?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).retrieveFlakyFailureinstance1(
        flakyFailureId,
        contentType,
        include,
        fieldsFlakyFailure,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the FlakyFailure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase3(
      flakyFailureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase3(
        flakyFailureId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update FlakyFailure attributes
     * @summary Update FlakyFailure
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyFailurePatchInst} pATCHBody FlakyFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFlakyFailure0(
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FlakyFailurePatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).updateFlakyFailure0(
        flakyFailureId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the FlakyFailure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase3(
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await FlakyFailureApiAxiosParamCreator(configuration).updatetestcase3(
        flakyFailureId,
        flakyFailureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * FlakyFailureApi - factory interface
 * @export
 */
export const FlakyFailureApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Add TestCase items to the FlakyFailure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase3(
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .addTestCaseitemstotestcase3(flakyFailureId, flakyFailureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create FlakyFailure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyFailurePostInst1} pOSTBody FlakyFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFlakyFailure0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: FlakyFailurePostInst1,
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .createFlakyFailure0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete FlakyFailure from FlakyFailure
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyFailurefromFlakyFailure0(
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .deleteFlakyFailurefromFlakyFailure0(flakyFailureId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the FlakyFailure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase3(
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .deleteTestCasefromtestcase3(flakyFailureId, flakyFailureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve FlakyFailure from FlakyFailure
     * @summary Retrieve a collection of FlakyFailure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyFailureinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<FlakyFailureGetColl> {
      return FlakyFailureApiFp(configuration)
        .retrieveFlakyFailureinstance0(
          contentType,
          include,
          fieldsFlakyFailure,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve FlakyFailure from FlakyFailure
     * @summary Retrieve FlakyFailure instance
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyFailureinstance1(
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsFlakyFailure?: string,
      options?: any
    ): AxiosPromise<object> {
      return FlakyFailureApiFp(configuration)
        .retrieveFlakyFailureinstance1(flakyFailureId, contentType, include, fieldsFlakyFailure, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the FlakyFailure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase3(
      flakyFailureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .retrieveTestCasefromtestcase3(
          flakyFailureId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update FlakyFailure attributes
     * @summary Update FlakyFailure
     * @param {string} flakyFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {FlakyFailurePatchInst} pATCHBody FlakyFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFlakyFailure0(
      flakyFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: FlakyFailurePatchInst,
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .updateFlakyFailure0(flakyFailureId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the FlakyFailure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} flakyFailureId FlakyFailure item
     * @param {FlakyFailureTestCaseRelationship} flakyFailureTestCaseBody FlakyFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase3(
      flakyFailureId: string,
      flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship,
      options?: any
    ): AxiosPromise<void> {
      return FlakyFailureApiFp(configuration)
        .updatetestcase3(flakyFailureId, flakyFailureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FlakyFailureApi - object-oriented interface
 * @export
 * @class FlakyFailureApi
 * @extends {BaseAPI}
 */
export class FlakyFailureApi extends BaseAPI {
  /**
   * Add TestCase items to the FlakyFailure test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} flakyFailureId FlakyFailure item
   * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public addTestCaseitemstotestcase3(
    flakyFailureId: string,
    flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .addTestCaseitemstotestcase3(flakyFailureId, flakyFailureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create FlakyFailure
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {FlakyFailurePostInst1} pOSTBody FlakyFailure attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public createFlakyFailure0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: FlakyFailurePostInst1,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .createFlakyFailure0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete FlakyFailure from FlakyFailure
   * @param {string} flakyFailureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public deleteFlakyFailurefromFlakyFailure0(
    flakyFailureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .deleteFlakyFailurefromFlakyFailure0(flakyFailureId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the FlakyFailure test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} flakyFailureId FlakyFailure item
   * @param {FlakyFailureTestCaseRelationship1} flakyFailureTestCaseBody FlakyFailure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public deleteTestCasefromtestcase3(
    flakyFailureId: string,
    flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship1,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .deleteTestCasefromtestcase3(flakyFailureId, flakyFailureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve FlakyFailure from FlakyFailure
   * @summary Retrieve a collection of FlakyFailure objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] FlakyFailure relationships to include (csv)
   * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom FlakyFailure filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public retrieveFlakyFailureinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsFlakyFailure?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .retrieveFlakyFailureinstance0(
        contentType,
        include,
        fieldsFlakyFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve FlakyFailure from FlakyFailure
   * @summary Retrieve FlakyFailure instance
   * @param {string} flakyFailureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] FlakyFailure relationships to include (csv)
   * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public retrieveFlakyFailureinstance1(
    flakyFailureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsFlakyFailure?: string,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .retrieveFlakyFailureinstance1(flakyFailureId, contentType, include, fieldsFlakyFailure, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the FlakyFailure test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} flakyFailureId FlakyFailure item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public retrieveTestCasefromtestcase3(
    flakyFailureId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .retrieveTestCasefromtestcase3(
        flakyFailureId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update FlakyFailure attributes
   * @summary Update FlakyFailure
   * @param {string} flakyFailureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {FlakyFailurePatchInst} pATCHBody FlakyFailure attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public updateFlakyFailure0(
    flakyFailureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: FlakyFailurePatchInst,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .updateFlakyFailure0(flakyFailureId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the FlakyFailure test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} flakyFailureId FlakyFailure item
   * @param {FlakyFailureTestCaseRelationship} flakyFailureTestCaseBody FlakyFailure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FlakyFailureApi
   */
  public updatetestcase3(
    flakyFailureId: string,
    flakyFailureTestCaseBody: FlakyFailureTestCaseRelationship,
    options?: any
  ) {
    return FlakyFailureApiFp(this.configuration)
      .updatetestcase3(flakyFailureId, flakyFailureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RerunErrorApi - axios parameter creator
 * @export
 */
export const RerunErrorApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the RerunError test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase4: async (
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling addTestCaseitemstotestcase4.'
        )
      }
      // verify required parameter 'rerunErrorTestCaseBody' is not null or undefined
      if (rerunErrorTestCaseBody === null || rerunErrorTestCaseBody === undefined) {
        throw new RequiredError(
          'rerunErrorTestCaseBody',
          'Required parameter rerunErrorTestCaseBody was null or undefined when calling addTestCaseitemstotestcase4.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/test_case`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof rerunErrorTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(rerunErrorTestCaseBody !== undefined ? rerunErrorTestCaseBody : {})
        : rerunErrorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create RerunError
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunErrorPostInst1} pOSTBody RerunError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRerunError0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: RerunErrorPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createRerunError0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createRerunError0.'
        )
      }
      const localVarPath = `/RerunError/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete RerunError from RerunError
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunErrorfromRerunError0: async (
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling deleteRerunErrorfromRerunError0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteRerunErrorfromRerunError0.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the RerunError test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase4: async (
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling deleteTestCasefromtestcase4.'
        )
      }
      // verify required parameter 'rerunErrorTestCaseBody' is not null or undefined
      if (rerunErrorTestCaseBody === null || rerunErrorTestCaseBody === undefined) {
        throw new RequiredError(
          'rerunErrorTestCaseBody',
          'Required parameter rerunErrorTestCaseBody was null or undefined when calling deleteTestCasefromtestcase4.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/test_case`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof rerunErrorTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(rerunErrorTestCaseBody !== undefined ? rerunErrorTestCaseBody : {})
        : rerunErrorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve RerunError from RerunError
     * @summary Retrieve a collection of RerunError objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunErrorinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveRerunErrorinstance0.'
        )
      }
      const localVarPath = `/RerunError/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsRerunError !== undefined) {
        localVarQueryParameter['fields[RerunError]'] = fieldsRerunError
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve RerunError from RerunError
     * @summary Retrieve RerunError instance
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunErrorinstance1: async (
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunError?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling retrieveRerunErrorinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveRerunErrorinstance1.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsRerunError !== undefined) {
        localVarQueryParameter['fields[RerunError]'] = fieldsRerunError
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the RerunError test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} rerunErrorId RerunError item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase4: async (
      rerunErrorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling retrieveTestCasefromtestcase4.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/test_case`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update RerunError attributes
     * @summary Update RerunError
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunErrorPatchInst} pATCHBody RerunError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRerunError0: async (
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: RerunErrorPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling updateRerunError0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateRerunError0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateRerunError0.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the RerunError test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase4: async (
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunErrorId' is not null or undefined
      if (rerunErrorId === null || rerunErrorId === undefined) {
        throw new RequiredError(
          'rerunErrorId',
          'Required parameter rerunErrorId was null or undefined when calling updatetestcase4.'
        )
      }
      // verify required parameter 'rerunErrorTestCaseBody' is not null or undefined
      if (rerunErrorTestCaseBody === null || rerunErrorTestCaseBody === undefined) {
        throw new RequiredError(
          'rerunErrorTestCaseBody',
          'Required parameter rerunErrorTestCaseBody was null or undefined when calling updatetestcase4.'
        )
      }
      const localVarPath = `/RerunError/{RerunErrorId}/test_case`.replace(
        `{${'RerunErrorId'}}`,
        encodeURIComponent(String(rerunErrorId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof rerunErrorTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(rerunErrorTestCaseBody !== undefined ? rerunErrorTestCaseBody : {})
        : rerunErrorTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RerunErrorApi - functional programming interface
 * @export
 */
export const RerunErrorApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the RerunError test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase4(
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).addTestCaseitemstotestcase4(
        rerunErrorId,
        rerunErrorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create RerunError
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunErrorPostInst1} pOSTBody RerunError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRerunError0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: RerunErrorPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).createRerunError0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete RerunError from RerunError
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRerunErrorfromRerunError0(
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).deleteRerunErrorfromRerunError0(
        rerunErrorId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the RerunError test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase4(
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).deleteTestCasefromtestcase4(
        rerunErrorId,
        rerunErrorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve RerunError from RerunError
     * @summary Retrieve a collection of RerunError objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveRerunErrorinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RerunErrorGetColl>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).retrieveRerunErrorinstance0(
        contentType,
        include,
        fieldsRerunError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve RerunError from RerunError
     * @summary Retrieve RerunError instance
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveRerunErrorinstance1(
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunError?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).retrieveRerunErrorinstance1(
        rerunErrorId,
        contentType,
        include,
        fieldsRerunError,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the RerunError test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} rerunErrorId RerunError item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase4(
      rerunErrorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase4(
        rerunErrorId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update RerunError attributes
     * @summary Update RerunError
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunErrorPatchInst} pATCHBody RerunError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRerunError0(
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: RerunErrorPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).updateRerunError0(
        rerunErrorId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the RerunError test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase4(
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunErrorApiAxiosParamCreator(configuration).updatetestcase4(
        rerunErrorId,
        rerunErrorTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RerunErrorApi - factory interface
 * @export
 */
export const RerunErrorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestCase items to the RerunError test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase4(
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .addTestCaseitemstotestcase4(rerunErrorId, rerunErrorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create RerunError
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunErrorPostInst1} pOSTBody RerunError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRerunError0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: RerunErrorPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .createRerunError0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete RerunError from RerunError
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunErrorfromRerunError0(
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .deleteRerunErrorfromRerunError0(rerunErrorId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the RerunError test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase4(
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .deleteTestCasefromtestcase4(rerunErrorId, rerunErrorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve RerunError from RerunError
     * @summary Retrieve a collection of RerunError objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunErrorinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<RerunErrorGetColl> {
      return RerunErrorApiFp(configuration)
        .retrieveRerunErrorinstance0(
          contentType,
          include,
          fieldsRerunError,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve RerunError from RerunError
     * @summary Retrieve RerunError instance
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunErrorinstance1(
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunError?: string,
      options?: any
    ): AxiosPromise<object> {
      return RerunErrorApiFp(configuration)
        .retrieveRerunErrorinstance1(rerunErrorId, contentType, include, fieldsRerunError, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the RerunError test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} rerunErrorId RerunError item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase4(
      rerunErrorId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .retrieveTestCasefromtestcase4(
          rerunErrorId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update RerunError attributes
     * @summary Update RerunError
     * @param {string} rerunErrorId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunErrorPatchInst} pATCHBody RerunError attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRerunError0(
      rerunErrorId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: RerunErrorPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .updateRerunError0(rerunErrorId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the RerunError test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} rerunErrorId RerunError item
     * @param {RerunErrorTestCaseRelationship} rerunErrorTestCaseBody RerunError.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase4(
      rerunErrorId: string,
      rerunErrorTestCaseBody: RerunErrorTestCaseRelationship,
      options?: any
    ): AxiosPromise<void> {
      return RerunErrorApiFp(configuration)
        .updatetestcase4(rerunErrorId, rerunErrorTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RerunErrorApi - object-oriented interface
 * @export
 * @class RerunErrorApi
 * @extends {BaseAPI}
 */
export class RerunErrorApi extends BaseAPI {
  /**
   * Add TestCase items to the RerunError test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} rerunErrorId RerunError item
   * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public addTestCaseitemstotestcase4(
    rerunErrorId: string,
    rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .addTestCaseitemstotestcase4(rerunErrorId, rerunErrorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create RerunError
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {RerunErrorPostInst1} pOSTBody RerunError attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public createRerunError0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: RerunErrorPostInst1,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .createRerunError0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete RerunError from RerunError
   * @param {string} rerunErrorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public deleteRerunErrorfromRerunError0(
    rerunErrorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .deleteRerunErrorfromRerunError0(rerunErrorId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the RerunError test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} rerunErrorId RerunError item
   * @param {RerunErrorTestCaseRelationship1} rerunErrorTestCaseBody RerunError.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public deleteTestCasefromtestcase4(
    rerunErrorId: string,
    rerunErrorTestCaseBody: RerunErrorTestCaseRelationship1,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .deleteTestCasefromtestcase4(rerunErrorId, rerunErrorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve RerunError from RerunError
   * @summary Retrieve a collection of RerunError objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] RerunError relationships to include (csv)
   * @param {string} [fieldsRerunError] RerunError fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom RerunError filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public retrieveRerunErrorinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsRerunError?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .retrieveRerunErrorinstance0(
        contentType,
        include,
        fieldsRerunError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve RerunError from RerunError
   * @summary Retrieve RerunError instance
   * @param {string} rerunErrorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] RerunError relationships to include (csv)
   * @param {string} [fieldsRerunError] RerunError fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public retrieveRerunErrorinstance1(
    rerunErrorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsRerunError?: string,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .retrieveRerunErrorinstance1(rerunErrorId, contentType, include, fieldsRerunError, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the RerunError test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} rerunErrorId RerunError item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public retrieveTestCasefromtestcase4(
    rerunErrorId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .retrieveTestCasefromtestcase4(
        rerunErrorId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update RerunError attributes
   * @summary Update RerunError
   * @param {string} rerunErrorId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {RerunErrorPatchInst} pATCHBody RerunError attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public updateRerunError0(
    rerunErrorId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: RerunErrorPatchInst,
    options?: any
  ) {
    return RerunErrorApiFp(this.configuration)
      .updateRerunError0(rerunErrorId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the RerunError test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} rerunErrorId RerunError item
   * @param {RerunErrorTestCaseRelationship} rerunErrorTestCaseBody RerunError.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunErrorApi
   */
  public updatetestcase4(rerunErrorId: string, rerunErrorTestCaseBody: RerunErrorTestCaseRelationship, options?: any) {
    return RerunErrorApiFp(this.configuration)
      .updatetestcase4(rerunErrorId, rerunErrorTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RerunFailureApi - axios parameter creator
 * @export
 */
export const RerunFailureApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the RerunFailure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase5: async (
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling addTestCaseitemstotestcase5.'
        )
      }
      // verify required parameter 'rerunFailureTestCaseBody' is not null or undefined
      if (rerunFailureTestCaseBody === null || rerunFailureTestCaseBody === undefined) {
        throw new RequiredError(
          'rerunFailureTestCaseBody',
          'Required parameter rerunFailureTestCaseBody was null or undefined when calling addTestCaseitemstotestcase5.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/test_case`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof rerunFailureTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(rerunFailureTestCaseBody !== undefined ? rerunFailureTestCaseBody : {})
        : rerunFailureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create RerunFailure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunFailurePostInst1} pOSTBody RerunFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRerunFailure0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: RerunFailurePostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createRerunFailure0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createRerunFailure0.'
        )
      }
      const localVarPath = `/RerunFailure/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete RerunFailure from RerunFailure
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunFailurefromRerunFailure0: async (
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling deleteRerunFailurefromRerunFailure0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteRerunFailurefromRerunFailure0.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the RerunFailure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase5: async (
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling deleteTestCasefromtestcase5.'
        )
      }
      // verify required parameter 'rerunFailureTestCaseBody' is not null or undefined
      if (rerunFailureTestCaseBody === null || rerunFailureTestCaseBody === undefined) {
        throw new RequiredError(
          'rerunFailureTestCaseBody',
          'Required parameter rerunFailureTestCaseBody was null or undefined when calling deleteTestCasefromtestcase5.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/test_case`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof rerunFailureTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(rerunFailureTestCaseBody !== undefined ? rerunFailureTestCaseBody : {})
        : rerunFailureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve RerunFailure from RerunFailure
     * @summary Retrieve a collection of RerunFailure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunFailureinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveRerunFailureinstance0.'
        )
      }
      const localVarPath = `/RerunFailure/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsRerunFailure !== undefined) {
        localVarQueryParameter['fields[RerunFailure]'] = fieldsRerunFailure
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve RerunFailure from RerunFailure
     * @summary Retrieve RerunFailure instance
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunFailureinstance1: async (
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunFailure?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling retrieveRerunFailureinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveRerunFailureinstance1.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsRerunFailure !== undefined) {
        localVarQueryParameter['fields[RerunFailure]'] = fieldsRerunFailure
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the RerunFailure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase5: async (
      rerunFailureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling retrieveTestCasefromtestcase5.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/test_case`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update RerunFailure attributes
     * @summary Update RerunFailure
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunFailurePatchInst} pATCHBody RerunFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRerunFailure0: async (
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: RerunFailurePatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling updateRerunFailure0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateRerunFailure0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateRerunFailure0.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the RerunFailure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase5: async (
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'rerunFailureId' is not null or undefined
      if (rerunFailureId === null || rerunFailureId === undefined) {
        throw new RequiredError(
          'rerunFailureId',
          'Required parameter rerunFailureId was null or undefined when calling updatetestcase5.'
        )
      }
      // verify required parameter 'rerunFailureTestCaseBody' is not null or undefined
      if (rerunFailureTestCaseBody === null || rerunFailureTestCaseBody === undefined) {
        throw new RequiredError(
          'rerunFailureTestCaseBody',
          'Required parameter rerunFailureTestCaseBody was null or undefined when calling updatetestcase5.'
        )
      }
      const localVarPath = `/RerunFailure/{RerunFailureId}/test_case`.replace(
        `{${'RerunFailureId'}}`,
        encodeURIComponent(String(rerunFailureId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof rerunFailureTestCaseBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(rerunFailureTestCaseBody !== undefined ? rerunFailureTestCaseBody : {})
        : rerunFailureTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RerunFailureApi - functional programming interface
 * @export
 */
export const RerunFailureApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the RerunFailure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase5(
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).addTestCaseitemstotestcase5(
        rerunFailureId,
        rerunFailureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create RerunFailure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunFailurePostInst1} pOSTBody RerunFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRerunFailure0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: RerunFailurePostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).createRerunFailure0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete RerunFailure from RerunFailure
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRerunFailurefromRerunFailure0(
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(
        configuration
      ).deleteRerunFailurefromRerunFailure0(rerunFailureId, contentType, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the RerunFailure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase5(
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).deleteTestCasefromtestcase5(
        rerunFailureId,
        rerunFailureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve RerunFailure from RerunFailure
     * @summary Retrieve a collection of RerunFailure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveRerunFailureinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RerunFailureGetColl>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).retrieveRerunFailureinstance0(
        contentType,
        include,
        fieldsRerunFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve RerunFailure from RerunFailure
     * @summary Retrieve RerunFailure instance
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveRerunFailureinstance1(
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunFailure?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).retrieveRerunFailureinstance1(
        rerunFailureId,
        contentType,
        include,
        fieldsRerunFailure,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the RerunFailure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase5(
      rerunFailureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase5(
        rerunFailureId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update RerunFailure attributes
     * @summary Update RerunFailure
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunFailurePatchInst} pATCHBody RerunFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRerunFailure0(
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: RerunFailurePatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).updateRerunFailure0(
        rerunFailureId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the RerunFailure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase5(
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await RerunFailureApiAxiosParamCreator(configuration).updatetestcase5(
        rerunFailureId,
        rerunFailureTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RerunFailureApi - factory interface
 * @export
 */
export const RerunFailureApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Add TestCase items to the RerunFailure test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase5(
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .addTestCaseitemstotestcase5(rerunFailureId, rerunFailureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create RerunFailure
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunFailurePostInst1} pOSTBody RerunFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRerunFailure0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: RerunFailurePostInst1,
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .createRerunFailure0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete RerunFailure from RerunFailure
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunFailurefromRerunFailure0(
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .deleteRerunFailurefromRerunFailure0(rerunFailureId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the RerunFailure test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase5(
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .deleteTestCasefromtestcase5(rerunFailureId, rerunFailureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve RerunFailure from RerunFailure
     * @summary Retrieve a collection of RerunFailure objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunFailureinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<RerunFailureGetColl> {
      return RerunFailureApiFp(configuration)
        .retrieveRerunFailureinstance0(
          contentType,
          include,
          fieldsRerunFailure,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve RerunFailure from RerunFailure
     * @summary Retrieve RerunFailure instance
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunFailureinstance1(
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsRerunFailure?: string,
      options?: any
    ): AxiosPromise<object> {
      return RerunFailureApiFp(configuration)
        .retrieveRerunFailureinstance1(rerunFailureId, contentType, include, fieldsRerunFailure, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the RerunFailure test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase5(
      rerunFailureId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .retrieveTestCasefromtestcase5(
          rerunFailureId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update RerunFailure attributes
     * @summary Update RerunFailure
     * @param {string} rerunFailureId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {RerunFailurePatchInst} pATCHBody RerunFailure attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRerunFailure0(
      rerunFailureId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: RerunFailurePatchInst,
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .updateRerunFailure0(rerunFailureId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the RerunFailure test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} rerunFailureId RerunFailure item
     * @param {RerunFailureTestCaseRelationship} rerunFailureTestCaseBody RerunFailure.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase5(
      rerunFailureId: string,
      rerunFailureTestCaseBody: RerunFailureTestCaseRelationship,
      options?: any
    ): AxiosPromise<void> {
      return RerunFailureApiFp(configuration)
        .updatetestcase5(rerunFailureId, rerunFailureTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RerunFailureApi - object-oriented interface
 * @export
 * @class RerunFailureApi
 * @extends {BaseAPI}
 */
export class RerunFailureApi extends BaseAPI {
  /**
   * Add TestCase items to the RerunFailure test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} rerunFailureId RerunFailure item
   * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public addTestCaseitemstotestcase5(
    rerunFailureId: string,
    rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .addTestCaseitemstotestcase5(rerunFailureId, rerunFailureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create RerunFailure
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {RerunFailurePostInst1} pOSTBody RerunFailure attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public createRerunFailure0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: RerunFailurePostInst1,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .createRerunFailure0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete RerunFailure from RerunFailure
   * @param {string} rerunFailureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public deleteRerunFailurefromRerunFailure0(
    rerunFailureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .deleteRerunFailurefromRerunFailure0(rerunFailureId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the RerunFailure test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} rerunFailureId RerunFailure item
   * @param {RerunFailureTestCaseRelationship1} rerunFailureTestCaseBody RerunFailure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public deleteTestCasefromtestcase5(
    rerunFailureId: string,
    rerunFailureTestCaseBody: RerunFailureTestCaseRelationship1,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .deleteTestCasefromtestcase5(rerunFailureId, rerunFailureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve RerunFailure from RerunFailure
   * @summary Retrieve a collection of RerunFailure objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] RerunFailure relationships to include (csv)
   * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom RerunFailure filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public retrieveRerunFailureinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsRerunFailure?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .retrieveRerunFailureinstance0(
        contentType,
        include,
        fieldsRerunFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve RerunFailure from RerunFailure
   * @summary Retrieve RerunFailure instance
   * @param {string} rerunFailureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] RerunFailure relationships to include (csv)
   * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public retrieveRerunFailureinstance1(
    rerunFailureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsRerunFailure?: string,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .retrieveRerunFailureinstance1(rerunFailureId, contentType, include, fieldsRerunFailure, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the RerunFailure test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} rerunFailureId RerunFailure item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public retrieveTestCasefromtestcase5(
    rerunFailureId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .retrieveTestCasefromtestcase5(
        rerunFailureId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update RerunFailure attributes
   * @summary Update RerunFailure
   * @param {string} rerunFailureId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {RerunFailurePatchInst} pATCHBody RerunFailure attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public updateRerunFailure0(
    rerunFailureId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: RerunFailurePatchInst,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .updateRerunFailure0(rerunFailureId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the RerunFailure test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} rerunFailureId RerunFailure item
   * @param {RerunFailureTestCaseRelationship} rerunFailureTestCaseBody RerunFailure.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RerunFailureApi
   */
  public updatetestcase5(
    rerunFailureId: string,
    rerunFailureTestCaseBody: RerunFailureTestCaseRelationship,
    options?: any
  ) {
    return RerunFailureApiFp(this.configuration)
      .updatetestcase5(rerunFailureId, rerunFailureTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SkippedApi - axios parameter creator
 * @export
 */
export const SkippedApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the Skipped test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase6: async (
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling addTestCaseitemstotestcase6.'
        )
      }
      // verify required parameter 'skippedTestCaseBody' is not null or undefined
      if (skippedTestCaseBody === null || skippedTestCaseBody === undefined) {
        throw new RequiredError(
          'skippedTestCaseBody',
          'Required parameter skippedTestCaseBody was null or undefined when calling addTestCaseitemstotestcase6.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/test_case`.replace(
        `{${'SkippedId'}}`,
        encodeURIComponent(String(skippedId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof skippedTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(skippedTestCaseBody !== undefined ? skippedTestCaseBody : {})
        : skippedTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Skipped
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {SkippedPostInst1} pOSTBody Skipped attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSkipped0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: SkippedPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createSkipped0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createSkipped0.'
        )
      }
      const localVarPath = `/Skipped/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete Skipped from Skipped
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSkippedfromSkipped0: async (
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling deleteSkippedfromSkipped0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteSkippedfromSkipped0.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/`.replace(`{${'SkippedId'}}`, encodeURIComponent(String(skippedId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the Skipped test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase6: async (
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling deleteTestCasefromtestcase6.'
        )
      }
      // verify required parameter 'skippedTestCaseBody' is not null or undefined
      if (skippedTestCaseBody === null || skippedTestCaseBody === undefined) {
        throw new RequiredError(
          'skippedTestCaseBody',
          'Required parameter skippedTestCaseBody was null or undefined when calling deleteTestCasefromtestcase6.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/test_case`.replace(
        `{${'SkippedId'}}`,
        encodeURIComponent(String(skippedId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof skippedTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(skippedTestCaseBody !== undefined ? skippedTestCaseBody : {})
        : skippedTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Skipped from Skipped
     * @summary Retrieve a collection of Skipped objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Skipped filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveSkippedinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsSkipped?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveSkippedinstance0.'
        )
      }
      const localVarPath = `/Skipped/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsSkipped !== undefined) {
        localVarQueryParameter['fields[Skipped]'] = fieldsSkipped
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Skipped from Skipped
     * @summary Retrieve Skipped instance
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveSkippedinstance1: async (
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsSkipped?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling retrieveSkippedinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveSkippedinstance1.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/`.replace(`{${'SkippedId'}}`, encodeURIComponent(String(skippedId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsSkipped !== undefined) {
        localVarQueryParameter['fields[Skipped]'] = fieldsSkipped
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the Skipped test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} skippedId Skipped item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase6: async (
      skippedId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling retrieveTestCasefromtestcase6.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/test_case`.replace(
        `{${'SkippedId'}}`,
        encodeURIComponent(String(skippedId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update Skipped attributes
     * @summary Update Skipped
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {SkippedPatchInst} pATCHBody Skipped attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSkipped0: async (
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: SkippedPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling updateSkipped0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateSkipped0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateSkipped0.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/`.replace(`{${'SkippedId'}}`, encodeURIComponent(String(skippedId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the Skipped test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase6: async (
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skippedId' is not null or undefined
      if (skippedId === null || skippedId === undefined) {
        throw new RequiredError(
          'skippedId',
          'Required parameter skippedId was null or undefined when calling updatetestcase6.'
        )
      }
      // verify required parameter 'skippedTestCaseBody' is not null or undefined
      if (skippedTestCaseBody === null || skippedTestCaseBody === undefined) {
        throw new RequiredError(
          'skippedTestCaseBody',
          'Required parameter skippedTestCaseBody was null or undefined when calling updatetestcase6.'
        )
      }
      const localVarPath = `/Skipped/{SkippedId}/test_case`.replace(
        `{${'SkippedId'}}`,
        encodeURIComponent(String(skippedId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof skippedTestCaseBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(skippedTestCaseBody !== undefined ? skippedTestCaseBody : {})
        : skippedTestCaseBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SkippedApi - functional programming interface
 * @export
 */
export const SkippedApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the Skipped test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcase6(
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).addTestCaseitemstotestcase6(
        skippedId,
        skippedTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Skipped
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {SkippedPostInst1} pOSTBody Skipped attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSkipped0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: SkippedPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).createSkipped0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete Skipped from Skipped
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSkippedfromSkipped0(
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).deleteSkippedfromSkipped0(
        skippedId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the Skipped test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcase6(
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).deleteTestCasefromtestcase6(
        skippedId,
        skippedTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Skipped from Skipped
     * @summary Retrieve a collection of Skipped objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Skipped filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveSkippedinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsSkipped?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkippedGetColl>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).retrieveSkippedinstance0(
        contentType,
        include,
        fieldsSkipped,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Skipped from Skipped
     * @summary Retrieve Skipped instance
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveSkippedinstance1(
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsSkipped?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).retrieveSkippedinstance1(
        skippedId,
        contentType,
        include,
        fieldsSkipped,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the Skipped test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} skippedId Skipped item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcase6(
      skippedId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).retrieveTestCasefromtestcase6(
        skippedId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update Skipped attributes
     * @summary Update Skipped
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {SkippedPatchInst} pATCHBody Skipped attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSkipped0(
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: SkippedPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).updateSkipped0(
        skippedId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the Skipped test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcase6(
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await SkippedApiAxiosParamCreator(configuration).updatetestcase6(
        skippedId,
        skippedTestCaseBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SkippedApi - factory interface
 * @export
 */
export const SkippedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestCase items to the Skipped test_case \"to-one\" relationship
     * @summary Add TestCase items to test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcase6(
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .addTestCaseitemstotestcase6(skippedId, skippedTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Skipped
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {SkippedPostInst1} pOSTBody Skipped attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSkipped0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: SkippedPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .createSkipped0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete Skipped from Skipped
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSkippedfromSkipped0(
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .deleteSkippedfromSkipped0(skippedId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the Skipped test_case \"to-one\" relationship
     * @summary Delete TestCase from test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcase6(
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .deleteTestCasefromtestcase6(skippedId, skippedTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Skipped from Skipped
     * @summary Retrieve a collection of Skipped objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Skipped filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveSkippedinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsSkipped?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<SkippedGetColl> {
      return SkippedApiFp(configuration)
        .retrieveSkippedinstance0(
          contentType,
          include,
          fieldsSkipped,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Skipped from Skipped
     * @summary Retrieve Skipped instance
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveSkippedinstance1(
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsSkipped?: string,
      options?: any
    ): AxiosPromise<object> {
      return SkippedApiFp(configuration)
        .retrieveSkippedinstance1(skippedId, contentType, include, fieldsSkipped, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the Skipped test_case \"to-one\" relationship
     * @summary Retrieve TestCase from test_case
     * @param {string} skippedId Skipped item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcase6(
      skippedId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .retrieveTestCasefromtestcase6(
          skippedId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update Skipped attributes
     * @summary Update Skipped
     * @param {string} skippedId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {SkippedPatchInst} pATCHBody Skipped attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSkipped0(
      skippedId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: SkippedPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .updateSkipped0(skippedId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the Skipped test_case \"to-one\" relationship
     * @summary Update test_case
     * @param {string} skippedId Skipped item
     * @param {SkippedTestCaseRelationship} skippedTestCaseBody Skipped.test_case POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcase6(
      skippedId: string,
      skippedTestCaseBody: SkippedTestCaseRelationship,
      options?: any
    ): AxiosPromise<void> {
      return SkippedApiFp(configuration)
        .updatetestcase6(skippedId, skippedTestCaseBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SkippedApi - object-oriented interface
 * @export
 * @class SkippedApi
 * @extends {BaseAPI}
 */
export class SkippedApi extends BaseAPI {
  /**
   * Add TestCase items to the Skipped test_case \"to-one\" relationship
   * @summary Add TestCase items to test_case
   * @param {string} skippedId Skipped item
   * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public addTestCaseitemstotestcase6(
    skippedId: string,
    skippedTestCaseBody: SkippedTestCaseRelationship1,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .addTestCaseitemstotestcase6(skippedId, skippedTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Skipped
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {SkippedPostInst1} pOSTBody Skipped attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public createSkipped0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: SkippedPostInst1,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .createSkipped0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete Skipped from Skipped
   * @param {string} skippedId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public deleteSkippedfromSkipped0(
    skippedId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .deleteSkippedfromSkipped0(skippedId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the Skipped test_case \"to-one\" relationship
   * @summary Delete TestCase from test_case
   * @param {string} skippedId Skipped item
   * @param {SkippedTestCaseRelationship1} skippedTestCaseBody Skipped.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public deleteTestCasefromtestcase6(
    skippedId: string,
    skippedTestCaseBody: SkippedTestCaseRelationship1,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .deleteTestCasefromtestcase6(skippedId, skippedTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Skipped from Skipped
   * @summary Retrieve a collection of Skipped objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] Skipped relationships to include (csv)
   * @param {string} [fieldsSkipped] Skipped fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom Skipped filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public retrieveSkippedinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsSkipped?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .retrieveSkippedinstance0(
        contentType,
        include,
        fieldsSkipped,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Skipped from Skipped
   * @summary Retrieve Skipped instance
   * @param {string} skippedId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] Skipped relationships to include (csv)
   * @param {string} [fieldsSkipped] Skipped fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public retrieveSkippedinstance1(
    skippedId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsSkipped?: string,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .retrieveSkippedinstance1(skippedId, contentType, include, fieldsSkipped, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the Skipped test_case \"to-one\" relationship
   * @summary Retrieve TestCase from test_case
   * @param {string} skippedId Skipped item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public retrieveTestCasefromtestcase6(
    skippedId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .retrieveTestCasefromtestcase6(
        skippedId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update Skipped attributes
   * @summary Update Skipped
   * @param {string} skippedId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {SkippedPatchInst} pATCHBody Skipped attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public updateSkipped0(
    skippedId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: SkippedPatchInst,
    options?: any
  ) {
    return SkippedApiFp(this.configuration)
      .updateSkipped0(skippedId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the Skipped test_case \"to-one\" relationship
   * @summary Update test_case
   * @param {string} skippedId Skipped item
   * @param {SkippedTestCaseRelationship} skippedTestCaseBody Skipped.test_case POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkippedApi
   */
  public updatetestcase6(skippedId: string, skippedTestCaseBody: SkippedTestCaseRelationship, options?: any) {
    return SkippedApiFp(this.configuration)
      .updatetestcase6(skippedId, skippedTestCaseBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TestCaseApi - axios parameter creator
 * @export
 */
export const TestCaseApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add Error items to the TestCase errors \"to-many\" relationship
     * @summary Add Error items to errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addErroritemstoerrors0: async (
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addErroritemstoerrors0.'
        )
      }
      // verify required parameter 'testCaseErrorsBody' is not null or undefined
      if (testCaseErrorsBody === null || testCaseErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseErrorsBody',
          'Required parameter testCaseErrorsBody was null or undefined when calling addErroritemstoerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseErrorsBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseErrorsBody !== undefined ? testCaseErrorsBody : {})
        : testCaseErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add Failure items to the TestCase failures \"to-many\" relationship
     * @summary Add Failure items to failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFailureitemstofailures0: async (
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addFailureitemstofailures0.'
        )
      }
      // verify required parameter 'testCaseFailuresBody' is not null or undefined
      if (testCaseFailuresBody === null || testCaseFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseFailuresBody',
          'Required parameter testCaseFailuresBody was null or undefined when calling addFailureitemstofailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFailuresBody !== undefined ? testCaseFailuresBody : {})
        : testCaseFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add FlakyError items to the TestCase flaky_errors \"to-many\" relationship
     * @summary Add FlakyError items to flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFlakyErroritemstoflakyerrors0: async (
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addFlakyErroritemstoflakyerrors0.'
        )
      }
      // verify required parameter 'testCaseFlakyErrorsBody' is not null or undefined
      if (testCaseFlakyErrorsBody === null || testCaseFlakyErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseFlakyErrorsBody',
          'Required parameter testCaseFlakyErrorsBody was null or undefined when calling addFlakyErroritemstoflakyerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFlakyErrorsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFlakyErrorsBody !== undefined ? testCaseFlakyErrorsBody : {})
        : testCaseFlakyErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add FlakyFailure items to the TestCase flaky_failures \"to-many\" relationship
     * @summary Add FlakyFailure items to flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFlakyFailureitemstoflakyfailures0: async (
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addFlakyFailureitemstoflakyfailures0.'
        )
      }
      // verify required parameter 'testCaseFlakyFailuresBody' is not null or undefined
      if (testCaseFlakyFailuresBody === null || testCaseFlakyFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseFlakyFailuresBody',
          'Required parameter testCaseFlakyFailuresBody was null or undefined when calling addFlakyFailureitemstoflakyfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFlakyFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFlakyFailuresBody !== undefined ? testCaseFlakyFailuresBody : {})
        : testCaseFlakyFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add RerunError items to the TestCase rerun_errors \"to-many\" relationship
     * @summary Add RerunError items to rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRerunErroritemstorerunerrors0: async (
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addRerunErroritemstorerunerrors0.'
        )
      }
      // verify required parameter 'testCaseRerunErrorsBody' is not null or undefined
      if (testCaseRerunErrorsBody === null || testCaseRerunErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseRerunErrorsBody',
          'Required parameter testCaseRerunErrorsBody was null or undefined when calling addRerunErroritemstorerunerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseRerunErrorsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseRerunErrorsBody !== undefined ? testCaseRerunErrorsBody : {})
        : testCaseRerunErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add RerunFailure items to the TestCase rerun_failures \"to-many\" relationship
     * @summary Add RerunFailure items to rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRerunFailureitemstorerunfailures0: async (
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addRerunFailureitemstorerunfailures0.'
        )
      }
      // verify required parameter 'testCaseRerunFailuresBody' is not null or undefined
      if (testCaseRerunFailuresBody === null || testCaseRerunFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseRerunFailuresBody',
          'Required parameter testCaseRerunFailuresBody was null or undefined when calling addRerunFailureitemstorerunfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseRerunFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseRerunFailuresBody !== undefined ? testCaseRerunFailuresBody : {})
        : testCaseRerunFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add Skipped items to the TestCase skippeds \"to-many\" relationship
     * @summary Add Skipped items to skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSkippeditemstoskippeds0: async (
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addSkippeditemstoskippeds0.'
        )
      }
      // verify required parameter 'testCaseSkippedsBody' is not null or undefined
      if (testCaseSkippedsBody === null || testCaseSkippedsBody === undefined) {
        throw new RequiredError(
          'testCaseSkippedsBody',
          'Required parameter testCaseSkippedsBody was null or undefined when calling addSkippeditemstoskippeds0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/skippeds`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseSkippedsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseSkippedsBody !== undefined ? testCaseSkippedsBody : {})
        : testCaseSkippedsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add TestCaseStatic items to the TestCase test_case_static \"to-one\" relationship
     * @summary Add TestCaseStatic items to test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseStaticitemstotestcasestatic0: async (
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addTestCaseStaticitemstotestcasestatic0.'
        )
      }
      // verify required parameter 'testCaseTestCaseStaticBody' is not null or undefined
      if (testCaseTestCaseStaticBody === null || testCaseTestCaseStaticBody === undefined) {
        throw new RequiredError(
          'testCaseTestCaseStaticBody',
          'Required parameter testCaseTestCaseStaticBody was null or undefined when calling addTestCaseStaticitemstotestcasestatic0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_case_static`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseTestCaseStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseTestCaseStaticBody !== undefined ? testCaseTestCaseStaticBody : {})
        : testCaseTestCaseStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add TestSuite items to the TestCase test_suite \"to-one\" relationship
     * @summary Add TestSuite items to test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteitemstotestsuite0: async (
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling addTestSuiteitemstotestsuite0.'
        )
      }
      // verify required parameter 'testCaseTestSuiteBody' is not null or undefined
      if (testCaseTestSuiteBody === null || testCaseTestSuiteBody === undefined) {
        throw new RequiredError(
          'testCaseTestSuiteBody',
          'Required parameter testCaseTestSuiteBody was null or undefined when calling addTestSuiteitemstotestsuite0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_suite`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseTestSuiteBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseTestSuiteBody !== undefined ? testCaseTestSuiteBody : {})
        : testCaseTestSuiteBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create TestCase
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCasePostInst1} pOSTBody TestCase attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestCase0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestCasePostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createTestCase0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createTestCase0.'
        )
      }
      const localVarPath = `/TestCase/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete Error items from the TestCase errors \"to-many\" relationship
     * @summary Delete Error from errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteErrorfromerrors0: async (
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteErrorfromerrors0.'
        )
      }
      // verify required parameter 'testCaseErrorsBody' is not null or undefined
      if (testCaseErrorsBody === null || testCaseErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseErrorsBody',
          'Required parameter testCaseErrorsBody was null or undefined when calling deleteErrorfromerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseErrorsBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseErrorsBody !== undefined ? testCaseErrorsBody : {})
        : testCaseErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete Failure items from the TestCase failures \"to-many\" relationship
     * @summary Delete Failure from failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFailurefromfailures0: async (
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteFailurefromfailures0.'
        )
      }
      // verify required parameter 'testCaseFailuresBody' is not null or undefined
      if (testCaseFailuresBody === null || testCaseFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseFailuresBody',
          'Required parameter testCaseFailuresBody was null or undefined when calling deleteFailurefromfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFailuresBody !== undefined ? testCaseFailuresBody : {})
        : testCaseFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete FlakyError items from the TestCase flaky_errors \"to-many\" relationship
     * @summary Delete FlakyError from flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyErrorfromflakyerrors0: async (
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteFlakyErrorfromflakyerrors0.'
        )
      }
      // verify required parameter 'testCaseFlakyErrorsBody' is not null or undefined
      if (testCaseFlakyErrorsBody === null || testCaseFlakyErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseFlakyErrorsBody',
          'Required parameter testCaseFlakyErrorsBody was null or undefined when calling deleteFlakyErrorfromflakyerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFlakyErrorsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFlakyErrorsBody !== undefined ? testCaseFlakyErrorsBody : {})
        : testCaseFlakyErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
     * @summary Delete FlakyFailure from flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyFailurefromflakyfailures0: async (
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteFlakyFailurefromflakyfailures0.'
        )
      }
      // verify required parameter 'testCaseFlakyFailuresBody' is not null or undefined
      if (testCaseFlakyFailuresBody === null || testCaseFlakyFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseFlakyFailuresBody',
          'Required parameter testCaseFlakyFailuresBody was null or undefined when calling deleteFlakyFailurefromflakyfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFlakyFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFlakyFailuresBody !== undefined ? testCaseFlakyFailuresBody : {})
        : testCaseFlakyFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete RerunError items from the TestCase rerun_errors \"to-many\" relationship
     * @summary Delete RerunError from rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunErrorfromrerunerrors0: async (
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteRerunErrorfromrerunerrors0.'
        )
      }
      // verify required parameter 'testCaseRerunErrorsBody' is not null or undefined
      if (testCaseRerunErrorsBody === null || testCaseRerunErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseRerunErrorsBody',
          'Required parameter testCaseRerunErrorsBody was null or undefined when calling deleteRerunErrorfromrerunerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseRerunErrorsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseRerunErrorsBody !== undefined ? testCaseRerunErrorsBody : {})
        : testCaseRerunErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
     * @summary Delete RerunFailure from rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunFailurefromrerunfailures0: async (
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteRerunFailurefromrerunfailures0.'
        )
      }
      // verify required parameter 'testCaseRerunFailuresBody' is not null or undefined
      if (testCaseRerunFailuresBody === null || testCaseRerunFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseRerunFailuresBody',
          'Required parameter testCaseRerunFailuresBody was null or undefined when calling deleteRerunFailurefromrerunfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseRerunFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseRerunFailuresBody !== undefined ? testCaseRerunFailuresBody : {})
        : testCaseRerunFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete Skipped items from the TestCase skippeds \"to-many\" relationship
     * @summary Delete Skipped from skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSkippedfromskippeds0: async (
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteSkippedfromskippeds0.'
        )
      }
      // verify required parameter 'testCaseSkippedsBody' is not null or undefined
      if (testCaseSkippedsBody === null || testCaseSkippedsBody === undefined) {
        throw new RequiredError(
          'testCaseSkippedsBody',
          'Required parameter testCaseSkippedsBody was null or undefined when calling deleteSkippedfromskippeds0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/skippeds`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseSkippedsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseSkippedsBody !== undefined ? testCaseSkippedsBody : {})
        : testCaseSkippedsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
     * @summary Delete TestCaseStatic from test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCaseStaticfromtestcasestatic0: async (
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteTestCaseStaticfromtestcasestatic0.'
        )
      }
      // verify required parameter 'testCaseTestCaseStaticBody' is not null or undefined
      if (testCaseTestCaseStaticBody === null || testCaseTestCaseStaticBody === undefined) {
        throw new RequiredError(
          'testCaseTestCaseStaticBody',
          'Required parameter testCaseTestCaseStaticBody was null or undefined when calling deleteTestCaseStaticfromtestcasestatic0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_case_static`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseTestCaseStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseTestCaseStaticBody !== undefined ? testCaseTestCaseStaticBody : {})
        : testCaseTestCaseStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete TestCase from TestCase
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromTestCase0: async (
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteTestCasefromTestCase0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteTestCasefromTestCase0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestSuite items from the TestCase test_suite \"to-one\" relationship
     * @summary Delete TestSuite from test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromtestsuite0: async (
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling deleteTestSuitefromtestsuite0.'
        )
      }
      // verify required parameter 'testCaseTestSuiteBody' is not null or undefined
      if (testCaseTestSuiteBody === null || testCaseTestSuiteBody === undefined) {
        throw new RequiredError(
          'testCaseTestSuiteBody',
          'Required parameter testCaseTestSuiteBody was null or undefined when calling deleteTestSuitefromtestsuite0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_suite`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseTestSuiteBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseTestSuiteBody !== undefined ? testCaseTestSuiteBody : {})
        : testCaseTestSuiteBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Error items from the TestCase errors \"to-many\" relationship
     * @summary Retrieve Error from errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Error filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveErrorfromerrors0: async (
      testCaseId: string,
      include?: string,
      fieldsError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveErrorfromerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsError !== undefined) {
        localVarQueryParameter['fields[Error]'] = fieldsError
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Failure items from the TestCase failures \"to-many\" relationship
     * @summary Retrieve Failure from failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Failure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFailurefromfailures0: async (
      testCaseId: string,
      include?: string,
      fieldsFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveFailurefromfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFailure !== undefined) {
        localVarQueryParameter['fields[Failure]'] = fieldsFailure
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve FlakyError items from the TestCase flaky_errors \"to-many\" relationship
     * @summary Retrieve FlakyError from flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyErrorfromflakyerrors0: async (
      testCaseId: string,
      include?: string,
      fieldsFlakyError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveFlakyErrorfromflakyerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFlakyError !== undefined) {
        localVarQueryParameter['fields[FlakyError]'] = fieldsFlakyError
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
     * @summary Retrieve FlakyFailure from flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyFailurefromflakyfailures0: async (
      testCaseId: string,
      include?: string,
      fieldsFlakyFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveFlakyFailurefromflakyfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsFlakyFailure !== undefined) {
        localVarQueryParameter['fields[FlakyFailure]'] = fieldsFlakyFailure
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve RerunError items from the TestCase rerun_errors \"to-many\" relationship
     * @summary Retrieve RerunError from rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunErrorfromrerunerrors0: async (
      testCaseId: string,
      include?: string,
      fieldsRerunError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveRerunErrorfromrerunerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsRerunError !== undefined) {
        localVarQueryParameter['fields[RerunError]'] = fieldsRerunError
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
     * @summary Retrieve RerunFailure from rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunFailurefromrerunfailures0: async (
      testCaseId: string,
      include?: string,
      fieldsRerunFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveRerunFailurefromrerunfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsRerunFailure !== undefined) {
        localVarQueryParameter['fields[RerunFailure]'] = fieldsRerunFailure
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterStackTrace !== undefined) {
        localVarQueryParameter['filter[stack_trace]'] = filterStackTrace
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve Skipped items from the TestCase skippeds \"to-many\" relationship
     * @summary Retrieve Skipped from skippeds
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Skipped filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveSkippedfromskippeds0: async (
      testCaseId: string,
      include?: string,
      fieldsSkipped?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveSkippedfromskippeds0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/skippeds`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsSkipped !== undefined) {
        localVarQueryParameter['fields[Skipped]'] = fieldsSkipped
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseId !== undefined) {
        localVarQueryParameter['filter[test_case_id]'] = filterTestCaseId
      }

      if (filterType !== undefined) {
        localVarQueryParameter['filter[Type]'] = filterType
      }

      if (filterMessage !== undefined) {
        localVarQueryParameter['filter[message]'] = filterMessage
      }

      if (filterValue !== undefined) {
        localVarQueryParameter['filter[value]'] = filterValue
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
     * @summary Retrieve TestCaseStatic from test_case_static
     * @param {string} testCaseId TestCase item
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticfromtestcasestatic0: async (
      testCaseId: string,
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveTestCaseStaticfromtestcasestatic0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_case_static`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCaseStatic !== undefined) {
        localVarQueryParameter['fields[TestCaseStatic]'] = fieldsTestCaseStatic
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterDescription !== undefined) {
        localVarQueryParameter['filter[description]'] = filterDescription
      }

      if (filterClassname !== undefined) {
        localVarQueryParameter['filter[classname]'] = filterClassname
      }

      if (filterGroup !== undefined) {
        localVarQueryParameter['filter[group]'] = filterGroup
      }

      if (filterFile !== undefined) {
        localVarQueryParameter['filter[file]'] = filterFile
      }

      if (filterLine !== undefined) {
        localVarQueryParameter['filter[line]'] = filterLine
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase from TestCase
     * @summary Retrieve a collection of TestCase objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestCaseinstance0.'
        )
      }
      const localVarPath = `/TestCase/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase from TestCase
     * @summary Retrieve TestCase instance
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseinstance1: async (
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCase?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveTestCaseinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestCaseinstance1.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuite items from the TestCase test_suite \"to-one\" relationship
     * @summary Retrieve TestSuite from test_suite
     * @param {string} testCaseId TestCase item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuitefromtestsuite0: async (
      testCaseId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling retrieveTestSuitefromtestsuite0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_suite`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuite !== undefined) {
        localVarQueryParameter['fields[TestSuite]'] = fieldsTestSuite
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterTestRunId !== undefined) {
        localVarQueryParameter['filter[test_run_id]'] = filterTestRunId
      }

      if (filterTests !== undefined) {
        localVarQueryParameter['filter[tests]'] = filterTests
      }

      if (filterFailures !== undefined) {
        localVarQueryParameter['filter[failures]'] = filterFailures
      }

      if (filterErrors !== undefined) {
        localVarQueryParameter['filter[errors]'] = filterErrors
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterSkipped !== undefined) {
        localVarQueryParameter['filter[skipped]'] = filterSkipped
      }

      if (filterTimestamp !== undefined) {
        localVarQueryParameter['filter[timestamp]'] = filterTimestamp
      }

      if (filterHostname !== undefined) {
        localVarQueryParameter['filter[hostname]'] = filterHostname
      }

      if (filterUrl !== undefined) {
        localVarQueryParameter['filter[url]'] = filterUrl
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update TestCase attributes
     * @summary Update TestCase
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCasePatchInst} pATCHBody TestCase attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestCase0: async (
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestCasePatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updateTestCase0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateTestCase0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateTestCase0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase errors \"to-many\" relationship
     * @summary Update errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateerrors0: async (
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updateerrors0.'
        )
      }
      // verify required parameter 'testCaseErrorsBody' is not null or undefined
      if (testCaseErrorsBody === null || testCaseErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseErrorsBody',
          'Required parameter testCaseErrorsBody was null or undefined when calling updateerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseErrorsBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseErrorsBody !== undefined ? testCaseErrorsBody : {})
        : testCaseErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase failures \"to-many\" relationship
     * @summary Update failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatefailures0: async (
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updatefailures0.'
        )
      }
      // verify required parameter 'testCaseFailuresBody' is not null or undefined
      if (testCaseFailuresBody === null || testCaseFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseFailuresBody',
          'Required parameter testCaseFailuresBody was null or undefined when calling updatefailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFailuresBody !== undefined ? testCaseFailuresBody : {})
        : testCaseFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase flaky_errors \"to-many\" relationship
     * @summary Update flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateflakyerrors0: async (
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updateflakyerrors0.'
        )
      }
      // verify required parameter 'testCaseFlakyErrorsBody' is not null or undefined
      if (testCaseFlakyErrorsBody === null || testCaseFlakyErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseFlakyErrorsBody',
          'Required parameter testCaseFlakyErrorsBody was null or undefined when calling updateflakyerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFlakyErrorsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFlakyErrorsBody !== undefined ? testCaseFlakyErrorsBody : {})
        : testCaseFlakyErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase flaky_failures \"to-many\" relationship
     * @summary Update flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateflakyfailures0: async (
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updateflakyfailures0.'
        )
      }
      // verify required parameter 'testCaseFlakyFailuresBody' is not null or undefined
      if (testCaseFlakyFailuresBody === null || testCaseFlakyFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseFlakyFailuresBody',
          'Required parameter testCaseFlakyFailuresBody was null or undefined when calling updateflakyfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/flaky_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseFlakyFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseFlakyFailuresBody !== undefined ? testCaseFlakyFailuresBody : {})
        : testCaseFlakyFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase rerun_errors \"to-many\" relationship
     * @summary Update rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatererunerrors0: async (
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updatererunerrors0.'
        )
      }
      // verify required parameter 'testCaseRerunErrorsBody' is not null or undefined
      if (testCaseRerunErrorsBody === null || testCaseRerunErrorsBody === undefined) {
        throw new RequiredError(
          'testCaseRerunErrorsBody',
          'Required parameter testCaseRerunErrorsBody was null or undefined when calling updatererunerrors0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_errors`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseRerunErrorsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseRerunErrorsBody !== undefined ? testCaseRerunErrorsBody : {})
        : testCaseRerunErrorsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase rerun_failures \"to-many\" relationship
     * @summary Update rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatererunfailures0: async (
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updatererunfailures0.'
        )
      }
      // verify required parameter 'testCaseRerunFailuresBody' is not null or undefined
      if (testCaseRerunFailuresBody === null || testCaseRerunFailuresBody === undefined) {
        throw new RequiredError(
          'testCaseRerunFailuresBody',
          'Required parameter testCaseRerunFailuresBody was null or undefined when calling updatererunfailures0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/rerun_failures`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseRerunFailuresBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseRerunFailuresBody !== undefined ? testCaseRerunFailuresBody : {})
        : testCaseRerunFailuresBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase skippeds \"to-many\" relationship
     * @summary Update skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateskippeds0: async (
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updateskippeds0.'
        )
      }
      // verify required parameter 'testCaseSkippedsBody' is not null or undefined
      if (testCaseSkippedsBody === null || testCaseSkippedsBody === undefined) {
        throw new RequiredError(
          'testCaseSkippedsBody',
          'Required parameter testCaseSkippedsBody was null or undefined when calling updateskippeds0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/skippeds`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseSkippedsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseSkippedsBody !== undefined ? testCaseSkippedsBody : {})
        : testCaseSkippedsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase test_case_static \"to-one\" relationship
     * @summary Update test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcasestatic0: async (
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updatetestcasestatic0.'
        )
      }
      // verify required parameter 'testCaseTestCaseStaticBody' is not null or undefined
      if (testCaseTestCaseStaticBody === null || testCaseTestCaseStaticBody === undefined) {
        throw new RequiredError(
          'testCaseTestCaseStaticBody',
          'Required parameter testCaseTestCaseStaticBody was null or undefined when calling updatetestcasestatic0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_case_static`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseTestCaseStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseTestCaseStaticBody !== undefined ? testCaseTestCaseStaticBody : {})
        : testCaseTestCaseStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCase test_suite \"to-one\" relationship
     * @summary Update test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuite0: async (
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseId' is not null or undefined
      if (testCaseId === null || testCaseId === undefined) {
        throw new RequiredError(
          'testCaseId',
          'Required parameter testCaseId was null or undefined when calling updatetestsuite0.'
        )
      }
      // verify required parameter 'testCaseTestSuiteBody' is not null or undefined
      if (testCaseTestSuiteBody === null || testCaseTestSuiteBody === undefined) {
        throw new RequiredError(
          'testCaseTestSuiteBody',
          'Required parameter testCaseTestSuiteBody was null or undefined when calling updatetestsuite0.'
        )
      }
      const localVarPath = `/TestCase/{TestCaseId}/test_suite`.replace(
        `{${'TestCaseId'}}`,
        encodeURIComponent(String(testCaseId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseTestSuiteBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseTestSuiteBody !== undefined ? testCaseTestSuiteBody : {})
        : testCaseTestSuiteBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TestCaseApi - functional programming interface
 * @export
 */
export const TestCaseApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add Error items to the TestCase errors \"to-many\" relationship
     * @summary Add Error items to errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addErroritemstoerrors0(
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addErroritemstoerrors0(
        testCaseId,
        testCaseErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add Failure items to the TestCase failures \"to-many\" relationship
     * @summary Add Failure items to failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFailureitemstofailures0(
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addFailureitemstofailures0(
        testCaseId,
        testCaseFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add FlakyError items to the TestCase flaky_errors \"to-many\" relationship
     * @summary Add FlakyError items to flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFlakyErroritemstoflakyerrors0(
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addFlakyErroritemstoflakyerrors0(
        testCaseId,
        testCaseFlakyErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add FlakyFailure items to the TestCase flaky_failures \"to-many\" relationship
     * @summary Add FlakyFailure items to flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFlakyFailureitemstoflakyfailures0(
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addFlakyFailureitemstoflakyfailures0(
        testCaseId,
        testCaseFlakyFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add RerunError items to the TestCase rerun_errors \"to-many\" relationship
     * @summary Add RerunError items to rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRerunErroritemstorerunerrors0(
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addRerunErroritemstorerunerrors0(
        testCaseId,
        testCaseRerunErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add RerunFailure items to the TestCase rerun_failures \"to-many\" relationship
     * @summary Add RerunFailure items to rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRerunFailureitemstorerunfailures0(
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addRerunFailureitemstorerunfailures0(
        testCaseId,
        testCaseRerunFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add Skipped items to the TestCase skippeds \"to-many\" relationship
     * @summary Add Skipped items to skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSkippeditemstoskippeds0(
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addSkippeditemstoskippeds0(
        testCaseId,
        testCaseSkippedsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add TestCaseStatic items to the TestCase test_case_static \"to-one\" relationship
     * @summary Add TestCaseStatic items to test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseStaticitemstotestcasestatic0(
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(
        configuration
      ).addTestCaseStaticitemstotestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add TestSuite items to the TestCase test_suite \"to-one\" relationship
     * @summary Add TestSuite items to test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestSuiteitemstotestsuite0(
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).addTestSuiteitemstotestsuite0(
        testCaseId,
        testCaseTestSuiteBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create TestCase
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCasePostInst1} pOSTBody TestCase attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTestCase0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestCasePostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).createTestCase0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete Error items from the TestCase errors \"to-many\" relationship
     * @summary Delete Error from errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteErrorfromerrors0(
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteErrorfromerrors0(
        testCaseId,
        testCaseErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete Failure items from the TestCase failures \"to-many\" relationship
     * @summary Delete Failure from failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFailurefromfailures0(
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteFailurefromfailures0(
        testCaseId,
        testCaseFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete FlakyError items from the TestCase flaky_errors \"to-many\" relationship
     * @summary Delete FlakyError from flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFlakyErrorfromflakyerrors0(
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteFlakyErrorfromflakyerrors0(
        testCaseId,
        testCaseFlakyErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
     * @summary Delete FlakyFailure from flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFlakyFailurefromflakyfailures0(
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteFlakyFailurefromflakyfailures0(
        testCaseId,
        testCaseFlakyFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete RerunError items from the TestCase rerun_errors \"to-many\" relationship
     * @summary Delete RerunError from rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRerunErrorfromrerunerrors0(
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteRerunErrorfromrerunerrors0(
        testCaseId,
        testCaseRerunErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
     * @summary Delete RerunFailure from rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRerunFailurefromrerunfailures0(
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteRerunFailurefromrerunfailures0(
        testCaseId,
        testCaseRerunFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete Skipped items from the TestCase skippeds \"to-many\" relationship
     * @summary Delete Skipped from skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSkippedfromskippeds0(
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteSkippedfromskippeds0(
        testCaseId,
        testCaseSkippedsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
     * @summary Delete TestCaseStatic from test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCaseStaticfromtestcasestatic0(
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(
        configuration
      ).deleteTestCaseStaticfromtestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete TestCase from TestCase
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromTestCase0(
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteTestCasefromTestCase0(
        testCaseId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestSuite items from the TestCase test_suite \"to-one\" relationship
     * @summary Delete TestSuite from test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuitefromtestsuite0(
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).deleteTestSuitefromtestsuite0(
        testCaseId,
        testCaseTestSuiteBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Error items from the TestCase errors \"to-many\" relationship
     * @summary Retrieve Error from errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Error filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveErrorfromerrors0(
      testCaseId: string,
      include?: string,
      fieldsError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveErrorfromerrors0(
        testCaseId,
        include,
        fieldsError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Failure items from the TestCase failures \"to-many\" relationship
     * @summary Retrieve Failure from failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Failure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFailurefromfailures0(
      testCaseId: string,
      include?: string,
      fieldsFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveFailurefromfailures0(
        testCaseId,
        include,
        fieldsFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve FlakyError items from the TestCase flaky_errors \"to-many\" relationship
     * @summary Retrieve FlakyError from flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFlakyErrorfromflakyerrors0(
      testCaseId: string,
      include?: string,
      fieldsFlakyError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveFlakyErrorfromflakyerrors0(
        testCaseId,
        include,
        fieldsFlakyError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
     * @summary Retrieve FlakyFailure from flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveFlakyFailurefromflakyfailures0(
      testCaseId: string,
      include?: string,
      fieldsFlakyFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(
        configuration
      ).retrieveFlakyFailurefromflakyfailures0(
        testCaseId,
        include,
        fieldsFlakyFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve RerunError items from the TestCase rerun_errors \"to-many\" relationship
     * @summary Retrieve RerunError from rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveRerunErrorfromrerunerrors0(
      testCaseId: string,
      include?: string,
      fieldsRerunError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveRerunErrorfromrerunerrors0(
        testCaseId,
        include,
        fieldsRerunError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
     * @summary Retrieve RerunFailure from rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveRerunFailurefromrerunfailures0(
      testCaseId: string,
      include?: string,
      fieldsRerunFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(
        configuration
      ).retrieveRerunFailurefromrerunfailures0(
        testCaseId,
        include,
        fieldsRerunFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve Skipped items from the TestCase skippeds \"to-many\" relationship
     * @summary Retrieve Skipped from skippeds
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Skipped filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveSkippedfromskippeds0(
      testCaseId: string,
      include?: string,
      fieldsSkipped?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveSkippedfromskippeds0(
        testCaseId,
        include,
        fieldsSkipped,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
     * @summary Retrieve TestCaseStatic from test_case_static
     * @param {string} testCaseId TestCase item
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCaseStaticfromtestcasestatic0(
      testCaseId: string,
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(
        configuration
      ).retrieveTestCaseStaticfromtestcasestatic0(
        testCaseId,
        include,
        fieldsTestCaseStatic,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterName,
        filterDescription,
        filterClassname,
        filterGroup,
        filterFile,
        filterLine,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase from TestCase
     * @summary Retrieve a collection of TestCase objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCaseinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestCaseGetColl>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveTestCaseinstance0(
        contentType,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase from TestCase
     * @summary Retrieve TestCase instance
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCaseinstance1(
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCase?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveTestCaseinstance1(
        testCaseId,
        contentType,
        include,
        fieldsTestCase,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuite items from the TestCase test_suite \"to-one\" relationship
     * @summary Retrieve TestSuite from test_suite
     * @param {string} testCaseId TestCase item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuitefromtestsuite0(
      testCaseId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).retrieveTestSuitefromtestsuite0(
        testCaseId,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update TestCase attributes
     * @summary Update TestCase
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCasePatchInst} pATCHBody TestCase attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTestCase0(
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestCasePatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updateTestCase0(
        testCaseId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase errors \"to-many\" relationship
     * @summary Update errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateerrors0(
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updateerrors0(
        testCaseId,
        testCaseErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase failures \"to-many\" relationship
     * @summary Update failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatefailures0(
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updatefailures0(
        testCaseId,
        testCaseFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase flaky_errors \"to-many\" relationship
     * @summary Update flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateflakyerrors0(
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updateflakyerrors0(
        testCaseId,
        testCaseFlakyErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase flaky_failures \"to-many\" relationship
     * @summary Update flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateflakyfailures0(
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updateflakyfailures0(
        testCaseId,
        testCaseFlakyFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase rerun_errors \"to-many\" relationship
     * @summary Update rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatererunerrors0(
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updatererunerrors0(
        testCaseId,
        testCaseRerunErrorsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase rerun_failures \"to-many\" relationship
     * @summary Update rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatererunfailures0(
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updatererunfailures0(
        testCaseId,
        testCaseRerunFailuresBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase skippeds \"to-many\" relationship
     * @summary Update skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateskippeds0(
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updateskippeds0(
        testCaseId,
        testCaseSkippedsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase test_case_static \"to-one\" relationship
     * @summary Update test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcasestatic0(
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updatetestcasestatic0(
        testCaseId,
        testCaseTestCaseStaticBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCase test_suite \"to-one\" relationship
     * @summary Update test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestsuite0(
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).updatetestsuite0(
        testCaseId,
        testCaseTestSuiteBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TestCaseApi - factory interface
 * @export
 */
export const TestCaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add Error items to the TestCase errors \"to-many\" relationship
     * @summary Add Error items to errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addErroritemstoerrors0(
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addErroritemstoerrors0(testCaseId, testCaseErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add Failure items to the TestCase failures \"to-many\" relationship
     * @summary Add Failure items to failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFailureitemstofailures0(
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addFailureitemstofailures0(testCaseId, testCaseFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add FlakyError items to the TestCase flaky_errors \"to-many\" relationship
     * @summary Add FlakyError items to flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFlakyErroritemstoflakyerrors0(
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addFlakyErroritemstoflakyerrors0(testCaseId, testCaseFlakyErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add FlakyFailure items to the TestCase flaky_failures \"to-many\" relationship
     * @summary Add FlakyFailure items to flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFlakyFailureitemstoflakyfailures0(
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addFlakyFailureitemstoflakyfailures0(testCaseId, testCaseFlakyFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add RerunError items to the TestCase rerun_errors \"to-many\" relationship
     * @summary Add RerunError items to rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRerunErroritemstorerunerrors0(
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addRerunErroritemstorerunerrors0(testCaseId, testCaseRerunErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add RerunFailure items to the TestCase rerun_failures \"to-many\" relationship
     * @summary Add RerunFailure items to rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRerunFailureitemstorerunfailures0(
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addRerunFailureitemstorerunfailures0(testCaseId, testCaseRerunFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add Skipped items to the TestCase skippeds \"to-many\" relationship
     * @summary Add Skipped items to skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSkippeditemstoskippeds0(
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addSkippeditemstoskippeds0(testCaseId, testCaseSkippedsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add TestCaseStatic items to the TestCase test_case_static \"to-one\" relationship
     * @summary Add TestCaseStatic items to test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseStaticitemstotestcasestatic0(
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addTestCaseStaticitemstotestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add TestSuite items to the TestCase test_suite \"to-one\" relationship
     * @summary Add TestSuite items to test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteitemstotestsuite0(
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .addTestSuiteitemstotestsuite0(testCaseId, testCaseTestSuiteBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create TestCase
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCasePostInst1} pOSTBody TestCase attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestCase0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestCasePostInst1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .createTestCase0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete Error items from the TestCase errors \"to-many\" relationship
     * @summary Delete Error from errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteErrorfromerrors0(
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteErrorfromerrors0(testCaseId, testCaseErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete Failure items from the TestCase failures \"to-many\" relationship
     * @summary Delete Failure from failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFailurefromfailures0(
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteFailurefromfailures0(testCaseId, testCaseFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete FlakyError items from the TestCase flaky_errors \"to-many\" relationship
     * @summary Delete FlakyError from flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyErrorfromflakyerrors0(
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteFlakyErrorfromflakyerrors0(testCaseId, testCaseFlakyErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
     * @summary Delete FlakyFailure from flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFlakyFailurefromflakyfailures0(
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteFlakyFailurefromflakyfailures0(testCaseId, testCaseFlakyFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete RerunError items from the TestCase rerun_errors \"to-many\" relationship
     * @summary Delete RerunError from rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunErrorfromrerunerrors0(
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteRerunErrorfromrerunerrors0(testCaseId, testCaseRerunErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
     * @summary Delete RerunFailure from rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRerunFailurefromrerunfailures0(
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteRerunFailurefromrerunfailures0(testCaseId, testCaseRerunFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete Skipped items from the TestCase skippeds \"to-many\" relationship
     * @summary Delete Skipped from skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSkippedfromskippeds0(
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteSkippedfromskippeds0(testCaseId, testCaseSkippedsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
     * @summary Delete TestCaseStatic from test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCaseStaticfromtestcasestatic0(
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteTestCaseStaticfromtestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete TestCase from TestCase
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromTestCase0(
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteTestCasefromTestCase0(testCaseId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestSuite items from the TestCase test_suite \"to-one\" relationship
     * @summary Delete TestSuite from test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromtestsuite0(
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .deleteTestSuitefromtestsuite0(testCaseId, testCaseTestSuiteBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Error items from the TestCase errors \"to-many\" relationship
     * @summary Retrieve Error from errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Error relationships to include (csv)
     * @param {string} [fieldsError] Error fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Error filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveErrorfromerrors0(
      testCaseId: string,
      include?: string,
      fieldsError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveErrorfromerrors0(
          testCaseId,
          include,
          fieldsError,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Failure items from the TestCase failures \"to-many\" relationship
     * @summary Retrieve Failure from failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Failure relationships to include (csv)
     * @param {string} [fieldsFailure] Failure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Failure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFailurefromfailures0(
      testCaseId: string,
      include?: string,
      fieldsFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveFailurefromfailures0(
          testCaseId,
          include,
          fieldsFailure,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve FlakyError items from the TestCase flaky_errors \"to-many\" relationship
     * @summary Retrieve FlakyError from flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] FlakyError relationships to include (csv)
     * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyErrorfromflakyerrors0(
      testCaseId: string,
      include?: string,
      fieldsFlakyError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveFlakyErrorfromflakyerrors0(
          testCaseId,
          include,
          fieldsFlakyError,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
     * @summary Retrieve FlakyFailure from flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] FlakyFailure relationships to include (csv)
     * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom FlakyFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveFlakyFailurefromflakyfailures0(
      testCaseId: string,
      include?: string,
      fieldsFlakyFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveFlakyFailurefromflakyfailures0(
          testCaseId,
          include,
          fieldsFlakyFailure,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve RerunError items from the TestCase rerun_errors \"to-many\" relationship
     * @summary Retrieve RerunError from rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {string} [include] RerunError relationships to include (csv)
     * @param {string} [fieldsRerunError] RerunError fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunError filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunErrorfromrerunerrors0(
      testCaseId: string,
      include?: string,
      fieldsRerunError?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveRerunErrorfromrerunerrors0(
          testCaseId,
          include,
          fieldsRerunError,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
     * @summary Retrieve RerunFailure from rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {string} [include] RerunFailure relationships to include (csv)
     * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom RerunFailure filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRerunFailurefromrerunfailures0(
      testCaseId: string,
      include?: string,
      fieldsRerunFailure?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterStackTrace?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveRerunFailurefromrerunfailures0(
          testCaseId,
          include,
          fieldsRerunFailure,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterStackTrace,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve Skipped items from the TestCase skippeds \"to-many\" relationship
     * @summary Retrieve Skipped from skippeds
     * @param {string} testCaseId TestCase item
     * @param {string} [include] Skipped relationships to include (csv)
     * @param {string} [fieldsSkipped] Skipped fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
     * @param {string} [filterType] Type attribute filter (csv)
     * @param {string} [filterMessage] message attribute filter (csv)
     * @param {string} [filterValue] value attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom Skipped filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveSkippedfromskippeds0(
      testCaseId: string,
      include?: string,
      fieldsSkipped?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseId?: string,
      filterType?: string,
      filterMessage?: string,
      filterValue?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveSkippedfromskippeds0(
          testCaseId,
          include,
          fieldsSkipped,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseId,
          filterType,
          filterMessage,
          filterValue,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
     * @summary Retrieve TestCaseStatic from test_case_static
     * @param {string} testCaseId TestCase item
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticfromtestcasestatic0(
      testCaseId: string,
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveTestCaseStaticfromtestcasestatic0(
          testCaseId,
          include,
          fieldsTestCaseStatic,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterName,
          filterDescription,
          filterClassname,
          filterGroup,
          filterFile,
          filterLine,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase from TestCase
     * @summary Retrieve a collection of TestCase objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<TestCaseGetColl> {
      return TestCaseApiFp(configuration)
        .retrieveTestCaseinstance0(
          contentType,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase from TestCase
     * @summary Retrieve TestCase instance
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseinstance1(
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCase?: string,
      options?: any
    ): AxiosPromise<object> {
      return TestCaseApiFp(configuration)
        .retrieveTestCaseinstance1(testCaseId, contentType, include, fieldsTestCase, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuite items from the TestCase test_suite \"to-one\" relationship
     * @summary Retrieve TestSuite from test_suite
     * @param {string} testCaseId TestCase item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuitefromtestsuite0(
      testCaseId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .retrieveTestSuitefromtestsuite0(
          testCaseId,
          include,
          fieldsTestSuite,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterTestRunId,
          filterTests,
          filterFailures,
          filterErrors,
          filterTime,
          filterSkipped,
          filterTimestamp,
          filterHostname,
          filterUrl,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update TestCase attributes
     * @summary Update TestCase
     * @param {string} testCaseId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCasePatchInst} pATCHBody TestCase attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestCase0(
      testCaseId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestCasePatchInst,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updateTestCase0(testCaseId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase errors \"to-many\" relationship
     * @summary Update errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseErrorsRelationship} testCaseErrorsBody TestCase.errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateerrors0(
      testCaseId: string,
      testCaseErrorsBody: TestCaseErrorsRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updateerrors0(testCaseId, testCaseErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase failures \"to-many\" relationship
     * @summary Update failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFailuresRelationship} testCaseFailuresBody TestCase.failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatefailures0(
      testCaseId: string,
      testCaseFailuresBody: TestCaseFailuresRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updatefailures0(testCaseId, testCaseFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase flaky_errors \"to-many\" relationship
     * @summary Update flaky_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyErrorsRelationship} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateflakyerrors0(
      testCaseId: string,
      testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updateflakyerrors0(testCaseId, testCaseFlakyErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase flaky_failures \"to-many\" relationship
     * @summary Update flaky_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseFlakyFailuresRelationship} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateflakyfailures0(
      testCaseId: string,
      testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updateflakyfailures0(testCaseId, testCaseFlakyFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase rerun_errors \"to-many\" relationship
     * @summary Update rerun_errors
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunErrorsRelationship} testCaseRerunErrorsBody TestCase.rerun_errors POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatererunerrors0(
      testCaseId: string,
      testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updatererunerrors0(testCaseId, testCaseRerunErrorsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase rerun_failures \"to-many\" relationship
     * @summary Update rerun_failures
     * @param {string} testCaseId TestCase item
     * @param {TestCaseRerunFailuresRelationship} testCaseRerunFailuresBody TestCase.rerun_failures POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatererunfailures0(
      testCaseId: string,
      testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updatererunfailures0(testCaseId, testCaseRerunFailuresBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase skippeds \"to-many\" relationship
     * @summary Update skippeds
     * @param {string} testCaseId TestCase item
     * @param {TestCaseSkippedsRelationship} testCaseSkippedsBody TestCase.skippeds POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateskippeds0(
      testCaseId: string,
      testCaseSkippedsBody: TestCaseSkippedsRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updateskippeds0(testCaseId, testCaseSkippedsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase test_case_static \"to-one\" relationship
     * @summary Update test_case_static
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestCaseStaticRelationship} testCaseTestCaseStaticBody TestCase.test_case_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcasestatic0(
      testCaseId: string,
      testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updatetestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCase test_suite \"to-one\" relationship
     * @summary Update test_suite
     * @param {string} testCaseId TestCase item
     * @param {TestCaseTestSuiteRelationship} testCaseTestSuiteBody TestCase.test_suite POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuite0(
      testCaseId: string,
      testCaseTestSuiteBody: TestCaseTestSuiteRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseApiFp(configuration)
        .updatetestsuite0(testCaseId, testCaseTestSuiteBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TestCaseApi - object-oriented interface
 * @export
 * @class TestCaseApi
 * @extends {BaseAPI}
 */
export class TestCaseApi extends BaseAPI {
  /**
   * Add Error items to the TestCase errors \"to-many\" relationship
   * @summary Add Error items to errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addErroritemstoerrors0(testCaseId: string, testCaseErrorsBody: TestCaseErrorsRelationship1, options?: any) {
    return TestCaseApiFp(this.configuration)
      .addErroritemstoerrors0(testCaseId, testCaseErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add Failure items to the TestCase failures \"to-many\" relationship
   * @summary Add Failure items to failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addFailureitemstofailures0(
    testCaseId: string,
    testCaseFailuresBody: TestCaseFailuresRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addFailureitemstofailures0(testCaseId, testCaseFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add FlakyError items to the TestCase flaky_errors \"to-many\" relationship
   * @summary Add FlakyError items to flaky_errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addFlakyErroritemstoflakyerrors0(
    testCaseId: string,
    testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addFlakyErroritemstoflakyerrors0(testCaseId, testCaseFlakyErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add FlakyFailure items to the TestCase flaky_failures \"to-many\" relationship
   * @summary Add FlakyFailure items to flaky_failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addFlakyFailureitemstoflakyfailures0(
    testCaseId: string,
    testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addFlakyFailureitemstoflakyfailures0(testCaseId, testCaseFlakyFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add RerunError items to the TestCase rerun_errors \"to-many\" relationship
   * @summary Add RerunError items to rerun_errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addRerunErroritemstorerunerrors0(
    testCaseId: string,
    testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addRerunErroritemstorerunerrors0(testCaseId, testCaseRerunErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add RerunFailure items to the TestCase rerun_failures \"to-many\" relationship
   * @summary Add RerunFailure items to rerun_failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addRerunFailureitemstorerunfailures0(
    testCaseId: string,
    testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addRerunFailureitemstorerunfailures0(testCaseId, testCaseRerunFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add Skipped items to the TestCase skippeds \"to-many\" relationship
   * @summary Add Skipped items to skippeds
   * @param {string} testCaseId TestCase item
   * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addSkippeditemstoskippeds0(
    testCaseId: string,
    testCaseSkippedsBody: TestCaseSkippedsRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addSkippeditemstoskippeds0(testCaseId, testCaseSkippedsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add TestCaseStatic items to the TestCase test_case_static \"to-one\" relationship
   * @summary Add TestCaseStatic items to test_case_static
   * @param {string} testCaseId TestCase item
   * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addTestCaseStaticitemstotestcasestatic0(
    testCaseId: string,
    testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addTestCaseStaticitemstotestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add TestSuite items to the TestCase test_suite \"to-one\" relationship
   * @summary Add TestSuite items to test_suite
   * @param {string} testCaseId TestCase item
   * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public addTestSuiteitemstotestsuite0(
    testCaseId: string,
    testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .addTestSuiteitemstotestsuite0(testCaseId, testCaseTestSuiteBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create TestCase
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestCasePostInst1} pOSTBody TestCase attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public createTestCase0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: TestCasePostInst1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .createTestCase0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete Error items from the TestCase errors \"to-many\" relationship
   * @summary Delete Error from errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseErrorsRelationship1} testCaseErrorsBody TestCase.errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteErrorfromerrors0(testCaseId: string, testCaseErrorsBody: TestCaseErrorsRelationship1, options?: any) {
    return TestCaseApiFp(this.configuration)
      .deleteErrorfromerrors0(testCaseId, testCaseErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete Failure items from the TestCase failures \"to-many\" relationship
   * @summary Delete Failure from failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFailuresRelationship1} testCaseFailuresBody TestCase.failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteFailurefromfailures0(
    testCaseId: string,
    testCaseFailuresBody: TestCaseFailuresRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteFailurefromfailures0(testCaseId, testCaseFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete FlakyError items from the TestCase flaky_errors \"to-many\" relationship
   * @summary Delete FlakyError from flaky_errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFlakyErrorsRelationship1} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteFlakyErrorfromflakyerrors0(
    testCaseId: string,
    testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteFlakyErrorfromflakyerrors0(testCaseId, testCaseFlakyErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
   * @summary Delete FlakyFailure from flaky_failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFlakyFailuresRelationship1} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteFlakyFailurefromflakyfailures0(
    testCaseId: string,
    testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteFlakyFailurefromflakyfailures0(testCaseId, testCaseFlakyFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete RerunError items from the TestCase rerun_errors \"to-many\" relationship
   * @summary Delete RerunError from rerun_errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseRerunErrorsRelationship1} testCaseRerunErrorsBody TestCase.rerun_errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteRerunErrorfromrerunerrors0(
    testCaseId: string,
    testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteRerunErrorfromrerunerrors0(testCaseId, testCaseRerunErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
   * @summary Delete RerunFailure from rerun_failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseRerunFailuresRelationship1} testCaseRerunFailuresBody TestCase.rerun_failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteRerunFailurefromrerunfailures0(
    testCaseId: string,
    testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteRerunFailurefromrerunfailures0(testCaseId, testCaseRerunFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete Skipped items from the TestCase skippeds \"to-many\" relationship
   * @summary Delete Skipped from skippeds
   * @param {string} testCaseId TestCase item
   * @param {TestCaseSkippedsRelationship1} testCaseSkippedsBody TestCase.skippeds POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteSkippedfromskippeds0(
    testCaseId: string,
    testCaseSkippedsBody: TestCaseSkippedsRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteSkippedfromskippeds0(testCaseId, testCaseSkippedsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
   * @summary Delete TestCaseStatic from test_case_static
   * @param {string} testCaseId TestCase item
   * @param {TestCaseTestCaseStaticRelationship1} testCaseTestCaseStaticBody TestCase.test_case_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteTestCaseStaticfromtestcasestatic0(
    testCaseId: string,
    testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteTestCaseStaticfromtestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete TestCase from TestCase
   * @param {string} testCaseId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteTestCasefromTestCase0(
    testCaseId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteTestCasefromTestCase0(testCaseId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestSuite items from the TestCase test_suite \"to-one\" relationship
   * @summary Delete TestSuite from test_suite
   * @param {string} testCaseId TestCase item
   * @param {TestCaseTestSuiteRelationship1} testCaseTestSuiteBody TestCase.test_suite POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public deleteTestSuitefromtestsuite0(
    testCaseId: string,
    testCaseTestSuiteBody: TestCaseTestSuiteRelationship1,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .deleteTestSuitefromtestsuite0(testCaseId, testCaseTestSuiteBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Error items from the TestCase errors \"to-many\" relationship
   * @summary Retrieve Error from errors
   * @param {string} testCaseId TestCase item
   * @param {string} [include] Error relationships to include (csv)
   * @param {string} [fieldsError] Error fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom Error filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveErrorfromerrors0(
    testCaseId: string,
    include?: string,
    fieldsError?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveErrorfromerrors0(
        testCaseId,
        include,
        fieldsError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Failure items from the TestCase failures \"to-many\" relationship
   * @summary Retrieve Failure from failures
   * @param {string} testCaseId TestCase item
   * @param {string} [include] Failure relationships to include (csv)
   * @param {string} [fieldsFailure] Failure fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom Failure filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveFailurefromfailures0(
    testCaseId: string,
    include?: string,
    fieldsFailure?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveFailurefromfailures0(
        testCaseId,
        include,
        fieldsFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve FlakyError items from the TestCase flaky_errors \"to-many\" relationship
   * @summary Retrieve FlakyError from flaky_errors
   * @param {string} testCaseId TestCase item
   * @param {string} [include] FlakyError relationships to include (csv)
   * @param {string} [fieldsFlakyError] FlakyError fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom FlakyError filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveFlakyErrorfromflakyerrors0(
    testCaseId: string,
    include?: string,
    fieldsFlakyError?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveFlakyErrorfromflakyerrors0(
        testCaseId,
        include,
        fieldsFlakyError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve FlakyFailure items from the TestCase flaky_failures \"to-many\" relationship
   * @summary Retrieve FlakyFailure from flaky_failures
   * @param {string} testCaseId TestCase item
   * @param {string} [include] FlakyFailure relationships to include (csv)
   * @param {string} [fieldsFlakyFailure] FlakyFailure fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom FlakyFailure filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveFlakyFailurefromflakyfailures0(
    testCaseId: string,
    include?: string,
    fieldsFlakyFailure?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveFlakyFailurefromflakyfailures0(
        testCaseId,
        include,
        fieldsFlakyFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve RerunError items from the TestCase rerun_errors \"to-many\" relationship
   * @summary Retrieve RerunError from rerun_errors
   * @param {string} testCaseId TestCase item
   * @param {string} [include] RerunError relationships to include (csv)
   * @param {string} [fieldsRerunError] RerunError fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom RerunError filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveRerunErrorfromrerunerrors0(
    testCaseId: string,
    include?: string,
    fieldsRerunError?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveRerunErrorfromrerunerrors0(
        testCaseId,
        include,
        fieldsRerunError,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve RerunFailure items from the TestCase rerun_failures \"to-many\" relationship
   * @summary Retrieve RerunFailure from rerun_failures
   * @param {string} testCaseId TestCase item
   * @param {string} [include] RerunFailure relationships to include (csv)
   * @param {string} [fieldsRerunFailure] RerunFailure fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterStackTrace] stack_trace attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom RerunFailure filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveRerunFailurefromrerunfailures0(
    testCaseId: string,
    include?: string,
    fieldsRerunFailure?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterStackTrace?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveRerunFailurefromrerunfailures0(
        testCaseId,
        include,
        fieldsRerunFailure,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterStackTrace,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve Skipped items from the TestCase skippeds \"to-many\" relationship
   * @summary Retrieve Skipped from skippeds
   * @param {string} testCaseId TestCase item
   * @param {string} [include] Skipped relationships to include (csv)
   * @param {string} [fieldsSkipped] Skipped fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseId] test_case_id attribute filter (csv)
   * @param {string} [filterType] Type attribute filter (csv)
   * @param {string} [filterMessage] message attribute filter (csv)
   * @param {string} [filterValue] value attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom Skipped filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveSkippedfromskippeds0(
    testCaseId: string,
    include?: string,
    fieldsSkipped?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseId?: string,
    filterType?: string,
    filterMessage?: string,
    filterValue?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveSkippedfromskippeds0(
        testCaseId,
        include,
        fieldsSkipped,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseId,
        filterType,
        filterMessage,
        filterValue,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCaseStatic items from the TestCase test_case_static \"to-one\" relationship
   * @summary Retrieve TestCaseStatic from test_case_static
   * @param {string} testCaseId TestCase item
   * @param {string} [include] TestCaseStatic relationships to include (csv)
   * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterDescription] description attribute filter (csv)
   * @param {string} [filterClassname] classname attribute filter (csv)
   * @param {string} [filterGroup] group attribute filter (csv)
   * @param {string} [filterFile] file attribute filter (csv)
   * @param {string} [filterLine] line attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCaseStatic filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveTestCaseStaticfromtestcasestatic0(
    testCaseId: string,
    include?: string,
    fieldsTestCaseStatic?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterName?: string,
    filterDescription?: string,
    filterClassname?: string,
    filterGroup?: string,
    filterFile?: string,
    filterLine?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveTestCaseStaticfromtestcasestatic0(
        testCaseId,
        include,
        fieldsTestCaseStatic,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterName,
        filterDescription,
        filterClassname,
        filterGroup,
        filterFile,
        filterLine,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase from TestCase
   * @summary Retrieve a collection of TestCase objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveTestCaseinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveTestCaseinstance0(
        contentType,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase from TestCase
   * @summary Retrieve TestCase instance
   * @param {string} testCaseId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveTestCaseinstance1(
    testCaseId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestCase?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveTestCaseinstance1(testCaseId, contentType, include, fieldsTestCase, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuite items from the TestCase test_suite \"to-one\" relationship
   * @summary Retrieve TestSuite from test_suite
   * @param {string} testCaseId TestCase item
   * @param {string} [include] TestSuite relationships to include (csv)
   * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
   * @param {string} [filterTests] tests attribute filter (csv)
   * @param {string} [filterFailures] failures attribute filter (csv)
   * @param {string} [filterErrors] errors attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterSkipped] skipped attribute filter (csv)
   * @param {string} [filterTimestamp] timestamp attribute filter (csv)
   * @param {string} [filterHostname] hostname attribute filter (csv)
   * @param {string} [filterUrl] url attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuite filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public retrieveTestSuitefromtestsuite0(
    testCaseId: string,
    include?: string,
    fieldsTestSuite?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterTestRunId?: string,
    filterTests?: string,
    filterFailures?: string,
    filterErrors?: string,
    filterTime?: string,
    filterSkipped?: string,
    filterTimestamp?: string,
    filterHostname?: string,
    filterUrl?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .retrieveTestSuitefromtestsuite0(
        testCaseId,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update TestCase attributes
   * @summary Update TestCase
   * @param {string} testCaseId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestCasePatchInst} pATCHBody TestCase attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updateTestCase0(
    testCaseId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: TestCasePatchInst,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .updateTestCase0(testCaseId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase errors \"to-many\" relationship
   * @summary Update errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseErrorsRelationship} testCaseErrorsBody TestCase.errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updateerrors0(testCaseId: string, testCaseErrorsBody: TestCaseErrorsRelationship, options?: any) {
    return TestCaseApiFp(this.configuration)
      .updateerrors0(testCaseId, testCaseErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase failures \"to-many\" relationship
   * @summary Update failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFailuresRelationship} testCaseFailuresBody TestCase.failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updatefailures0(testCaseId: string, testCaseFailuresBody: TestCaseFailuresRelationship, options?: any) {
    return TestCaseApiFp(this.configuration)
      .updatefailures0(testCaseId, testCaseFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase flaky_errors \"to-many\" relationship
   * @summary Update flaky_errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFlakyErrorsRelationship} testCaseFlakyErrorsBody TestCase.flaky_errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updateflakyerrors0(
    testCaseId: string,
    testCaseFlakyErrorsBody: TestCaseFlakyErrorsRelationship,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .updateflakyerrors0(testCaseId, testCaseFlakyErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase flaky_failures \"to-many\" relationship
   * @summary Update flaky_failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseFlakyFailuresRelationship} testCaseFlakyFailuresBody TestCase.flaky_failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updateflakyfailures0(
    testCaseId: string,
    testCaseFlakyFailuresBody: TestCaseFlakyFailuresRelationship,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .updateflakyfailures0(testCaseId, testCaseFlakyFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase rerun_errors \"to-many\" relationship
   * @summary Update rerun_errors
   * @param {string} testCaseId TestCase item
   * @param {TestCaseRerunErrorsRelationship} testCaseRerunErrorsBody TestCase.rerun_errors POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updatererunerrors0(
    testCaseId: string,
    testCaseRerunErrorsBody: TestCaseRerunErrorsRelationship,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .updatererunerrors0(testCaseId, testCaseRerunErrorsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase rerun_failures \"to-many\" relationship
   * @summary Update rerun_failures
   * @param {string} testCaseId TestCase item
   * @param {TestCaseRerunFailuresRelationship} testCaseRerunFailuresBody TestCase.rerun_failures POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updatererunfailures0(
    testCaseId: string,
    testCaseRerunFailuresBody: TestCaseRerunFailuresRelationship,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .updatererunfailures0(testCaseId, testCaseRerunFailuresBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase skippeds \"to-many\" relationship
   * @summary Update skippeds
   * @param {string} testCaseId TestCase item
   * @param {TestCaseSkippedsRelationship} testCaseSkippedsBody TestCase.skippeds POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updateskippeds0(testCaseId: string, testCaseSkippedsBody: TestCaseSkippedsRelationship, options?: any) {
    return TestCaseApiFp(this.configuration)
      .updateskippeds0(testCaseId, testCaseSkippedsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase test_case_static \"to-one\" relationship
   * @summary Update test_case_static
   * @param {string} testCaseId TestCase item
   * @param {TestCaseTestCaseStaticRelationship} testCaseTestCaseStaticBody TestCase.test_case_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updatetestcasestatic0(
    testCaseId: string,
    testCaseTestCaseStaticBody: TestCaseTestCaseStaticRelationship,
    options?: any
  ) {
    return TestCaseApiFp(this.configuration)
      .updatetestcasestatic0(testCaseId, testCaseTestCaseStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCase test_suite \"to-one\" relationship
   * @summary Update test_suite
   * @param {string} testCaseId TestCase item
   * @param {TestCaseTestSuiteRelationship} testCaseTestSuiteBody TestCase.test_suite POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseApi
   */
  public updatetestsuite0(testCaseId: string, testCaseTestSuiteBody: TestCaseTestSuiteRelationship, options?: any) {
    return TestCaseApiFp(this.configuration)
      .updatetestsuite0(testCaseId, testCaseTestSuiteBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TestCaseStaticApi - axios parameter creator
 * @export
 */
export const TestCaseStaticApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Add TestCase items to test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcases0: async (
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling addTestCaseitemstotestcases0.'
        )
      }
      // verify required parameter 'testCaseStaticTestCasesBody' is not null or undefined
      if (testCaseStaticTestCasesBody === null || testCaseStaticTestCasesBody === undefined) {
        throw new RequiredError(
          'testCaseStaticTestCasesBody',
          'Required parameter testCaseStaticTestCasesBody was null or undefined when calling addTestCaseitemstotestcases0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_cases`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseStaticTestCasesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseStaticTestCasesBody !== undefined ? testCaseStaticTestCasesBody : {})
        : testCaseStaticTestCasesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add TestSuiteStatic items to the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Add TestSuiteStatic items to test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteStaticitemstotestsuitestatic0: async (
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling addTestSuiteStaticitemstotestsuitestatic0.'
        )
      }
      // verify required parameter 'testCaseStaticTestSuiteStaticBody' is not null or undefined
      if (testCaseStaticTestSuiteStaticBody === null || testCaseStaticTestSuiteStaticBody === undefined) {
        throw new RequiredError(
          'testCaseStaticTestSuiteStaticBody',
          'Required parameter testCaseStaticTestSuiteStaticBody was null or undefined when calling addTestSuiteStaticitemstotestsuitestatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_suite_static`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseStaticTestSuiteStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseStaticTestSuiteStaticBody !== undefined ? testCaseStaticTestSuiteStaticBody : {})
        : testCaseStaticTestSuiteStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create TestCaseStatic
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCaseStaticPostInst1} pOSTBody TestCaseStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestCaseStatic0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestCaseStaticPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createTestCaseStatic0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createTestCaseStatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete TestCaseStatic from TestCaseStatic
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCaseStaticfromTestCaseStatic0: async (
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling deleteTestCaseStaticfromTestCaseStatic0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteTestCaseStaticfromTestCaseStatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Delete TestCase from test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcases0: async (
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling deleteTestCasefromtestcases0.'
        )
      }
      // verify required parameter 'testCaseStaticTestCasesBody' is not null or undefined
      if (testCaseStaticTestCasesBody === null || testCaseStaticTestCasesBody === undefined) {
        throw new RequiredError(
          'testCaseStaticTestCasesBody',
          'Required parameter testCaseStaticTestCasesBody was null or undefined when calling deleteTestCasefromtestcases0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_cases`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseStaticTestCasesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseStaticTestCasesBody !== undefined ? testCaseStaticTestCasesBody : {})
        : testCaseStaticTestCasesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Delete TestSuiteStatic from test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuiteStaticfromtestsuitestatic0: async (
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling deleteTestSuiteStaticfromtestsuitestatic0.'
        )
      }
      // verify required parameter 'testCaseStaticTestSuiteStaticBody' is not null or undefined
      if (testCaseStaticTestSuiteStaticBody === null || testCaseStaticTestSuiteStaticBody === undefined) {
        throw new RequiredError(
          'testCaseStaticTestSuiteStaticBody',
          'Required parameter testCaseStaticTestSuiteStaticBody was null or undefined when calling deleteTestSuiteStaticfromtestsuitestatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_suite_static`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseStaticTestSuiteStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseStaticTestSuiteStaticBody !== undefined ? testCaseStaticTestSuiteStaticBody : {})
        : testCaseStaticTestSuiteStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCaseStatic from TestCaseStatic
     * @summary Retrieve a collection of TestCaseStatic objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestCaseStaticinstance0.'
        )
      }
      const localVarPath = `/TestCaseStatic/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCaseStatic !== undefined) {
        localVarQueryParameter['fields[TestCaseStatic]'] = fieldsTestCaseStatic
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterDescription !== undefined) {
        localVarQueryParameter['filter[description]'] = filterDescription
      }

      if (filterClassname !== undefined) {
        localVarQueryParameter['filter[classname]'] = filterClassname
      }

      if (filterGroup !== undefined) {
        localVarQueryParameter['filter[group]'] = filterGroup
      }

      if (filterFile !== undefined) {
        localVarQueryParameter['filter[file]'] = filterFile
      }

      if (filterLine !== undefined) {
        localVarQueryParameter['filter[line]'] = filterLine
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCaseStatic from TestCaseStatic
     * @summary Retrieve TestCaseStatic instance
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticinstance1: async (
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCaseStatic?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling retrieveTestCaseStaticinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestCaseStaticinstance1.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCaseStatic !== undefined) {
        localVarQueryParameter['fields[TestCaseStatic]'] = fieldsTestCaseStatic
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Retrieve TestCase from test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcases0: async (
      testCaseStaticId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling retrieveTestCasefromtestcases0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_cases`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Retrieve TestSuiteStatic from test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticfromtestsuitestatic0: async (
      testCaseStaticId: string,
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling retrieveTestSuiteStaticfromtestsuitestatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_suite_static`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuiteStatic !== undefined) {
        localVarQueryParameter['fields[TestSuiteStatic]'] = fieldsTestSuiteStatic
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterDescription !== undefined) {
        localVarQueryParameter['filter[description]'] = filterDescription
      }

      if (filterPackage !== undefined) {
        localVarQueryParameter['filter[package]'] = filterPackage
      }

      if (filterGroup !== undefined) {
        localVarQueryParameter['filter[group]'] = filterGroup
      }

      if (filterFile !== undefined) {
        localVarQueryParameter['filter[file]'] = filterFile
      }

      if (filterLog !== undefined) {
        localVarQueryParameter['filter[log]'] = filterLog
      }

      if (filterVersion !== undefined) {
        localVarQueryParameter['filter[version]'] = filterVersion
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update TestCaseStatic attributes
     * @summary Update TestCaseStatic
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCaseStaticPatchInst} pATCHBody TestCaseStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestCaseStatic0: async (
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestCaseStaticPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling updateTestCaseStatic0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateTestCaseStatic0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateTestCaseStatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Update test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcases0: async (
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling updatetestcases0.'
        )
      }
      // verify required parameter 'testCaseStaticTestCasesBody' is not null or undefined
      if (testCaseStaticTestCasesBody === null || testCaseStaticTestCasesBody === undefined) {
        throw new RequiredError(
          'testCaseStaticTestCasesBody',
          'Required parameter testCaseStaticTestCasesBody was null or undefined when calling updatetestcases0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_cases`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseStaticTestCasesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseStaticTestCasesBody !== undefined ? testCaseStaticTestCasesBody : {})
        : testCaseStaticTestCasesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Update test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuitestatic0: async (
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testCaseStaticId' is not null or undefined
      if (testCaseStaticId === null || testCaseStaticId === undefined) {
        throw new RequiredError(
          'testCaseStaticId',
          'Required parameter testCaseStaticId was null or undefined when calling updatetestsuitestatic0.'
        )
      }
      // verify required parameter 'testCaseStaticTestSuiteStaticBody' is not null or undefined
      if (testCaseStaticTestSuiteStaticBody === null || testCaseStaticTestSuiteStaticBody === undefined) {
        throw new RequiredError(
          'testCaseStaticTestSuiteStaticBody',
          'Required parameter testCaseStaticTestSuiteStaticBody was null or undefined when calling updatetestsuitestatic0.'
        )
      }
      const localVarPath = `/TestCaseStatic/{TestCaseStaticId}/test_suite_static`.replace(
        `{${'TestCaseStaticId'}}`,
        encodeURIComponent(String(testCaseStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testCaseStaticTestSuiteStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testCaseStaticTestSuiteStaticBody !== undefined ? testCaseStaticTestSuiteStaticBody : {})
        : testCaseStaticTestSuiteStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TestCaseStaticApi - functional programming interface
 * @export
 */
export const TestCaseStaticApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Add TestCase items to test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcases0(
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).addTestCaseitemstotestcases0(
        testCaseStaticId,
        testCaseStaticTestCasesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add TestSuiteStatic items to the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Add TestSuiteStatic items to test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestSuiteStaticitemstotestsuitestatic0(
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(
        configuration
      ).addTestSuiteStaticitemstotestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create TestCaseStatic
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCaseStaticPostInst1} pOSTBody TestCaseStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTestCaseStatic0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestCaseStaticPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).createTestCaseStatic0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete TestCaseStatic from TestCaseStatic
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCaseStaticfromTestCaseStatic0(
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(
        configuration
      ).deleteTestCaseStaticfromTestCaseStatic0(testCaseStaticId, contentType, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Delete TestCase from test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcases0(
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).deleteTestCasefromtestcases0(
        testCaseStaticId,
        testCaseStaticTestCasesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Delete TestSuiteStatic from test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuiteStaticfromtestsuitestatic0(
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(
        configuration
      ).deleteTestSuiteStaticfromtestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCaseStatic from TestCaseStatic
     * @summary Retrieve a collection of TestCaseStatic objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCaseStaticinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestCaseStaticGetColl>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).retrieveTestCaseStaticinstance0(
        contentType,
        include,
        fieldsTestCaseStatic,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterName,
        filterDescription,
        filterClassname,
        filterGroup,
        filterFile,
        filterLine,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCaseStatic from TestCaseStatic
     * @summary Retrieve TestCaseStatic instance
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCaseStaticinstance1(
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCaseStatic?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).retrieveTestCaseStaticinstance1(
        testCaseStaticId,
        contentType,
        include,
        fieldsTestCaseStatic,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Retrieve TestCase from test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcases0(
      testCaseStaticId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).retrieveTestCasefromtestcases0(
        testCaseStaticId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Retrieve TestSuiteStatic from test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuiteStaticfromtestsuitestatic0(
      testCaseStaticId: string,
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(
        configuration
      ).retrieveTestSuiteStaticfromtestsuitestatic0(
        testCaseStaticId,
        include,
        fieldsTestSuiteStatic,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterDescription,
        filterPackage,
        filterGroup,
        filterFile,
        filterLog,
        filterVersion,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update TestCaseStatic attributes
     * @summary Update TestCaseStatic
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCaseStaticPatchInst} pATCHBody TestCaseStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTestCaseStatic0(
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestCaseStaticPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).updateTestCaseStatic0(
        testCaseStaticId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Update test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcases0(
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).updatetestcases0(
        testCaseStaticId,
        testCaseStaticTestCasesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Update test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestsuitestatic0(
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestCaseStaticApiAxiosParamCreator(configuration).updatetestsuitestatic0(
        testCaseStaticId,
        testCaseStaticTestSuiteStaticBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TestCaseStaticApi - factory interface
 * @export
 */
export const TestCaseStaticApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Add TestCase items to the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Add TestCase items to test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcases0(
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .addTestCaseitemstotestcases0(testCaseStaticId, testCaseStaticTestCasesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add TestSuiteStatic items to the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Add TestSuiteStatic items to test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteStaticitemstotestsuitestatic0(
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .addTestSuiteStaticitemstotestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create TestCaseStatic
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCaseStaticPostInst1} pOSTBody TestCaseStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestCaseStatic0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestCaseStaticPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .createTestCaseStatic0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete TestCaseStatic from TestCaseStatic
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCaseStaticfromTestCaseStatic0(
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .deleteTestCaseStaticfromTestCaseStatic0(testCaseStaticId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Delete TestCase from test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcases0(
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .deleteTestCasefromtestcases0(testCaseStaticId, testCaseStaticTestCasesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Delete TestSuiteStatic from test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuiteStaticfromtestsuitestatic0(
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .deleteTestSuiteStaticfromtestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCaseStatic from TestCaseStatic
     * @summary Retrieve a collection of TestCaseStatic objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<TestCaseStaticGetColl> {
      return TestCaseStaticApiFp(configuration)
        .retrieveTestCaseStaticinstance0(
          contentType,
          include,
          fieldsTestCaseStatic,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterName,
          filterDescription,
          filterClassname,
          filterGroup,
          filterFile,
          filterLine,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCaseStatic from TestCaseStatic
     * @summary Retrieve TestCaseStatic instance
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticinstance1(
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestCaseStatic?: string,
      options?: any
    ): AxiosPromise<object> {
      return TestCaseStaticApiFp(configuration)
        .retrieveTestCaseStaticinstance1(testCaseStaticId, contentType, include, fieldsTestCaseStatic, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Retrieve TestCase from test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcases0(
      testCaseStaticId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .retrieveTestCasefromtestcases0(
          testCaseStaticId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Retrieve TestSuiteStatic from test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticfromtestsuitestatic0(
      testCaseStaticId: string,
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .retrieveTestSuiteStaticfromtestsuitestatic0(
          testCaseStaticId,
          include,
          fieldsTestSuiteStatic,
          pageOffset,
          pageLimit,
          sort,
          filterName,
          filterDescription,
          filterPackage,
          filterGroup,
          filterFile,
          filterLog,
          filterVersion,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update TestCaseStatic attributes
     * @summary Update TestCaseStatic
     * @param {string} testCaseStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestCaseStaticPatchInst} pATCHBody TestCaseStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestCaseStatic0(
      testCaseStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestCaseStaticPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .updateTestCaseStatic0(testCaseStaticId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCaseStatic test_cases \"to-many\" relationship
     * @summary Update test_cases
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestCasesRelationship} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcases0(
      testCaseStaticId: string,
      testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .updatetestcases0(testCaseStaticId, testCaseStaticTestCasesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestCaseStatic test_suite_static \"to-one\" relationship
     * @summary Update test_suite_static
     * @param {string} testCaseStaticId TestCaseStatic item
     * @param {TestCaseStaticTestSuiteStaticRelationship} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuitestatic0(
      testCaseStaticId: string,
      testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestCaseStaticApiFp(configuration)
        .updatetestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TestCaseStaticApi - object-oriented interface
 * @export
 * @class TestCaseStaticApi
 * @extends {BaseAPI}
 */
export class TestCaseStaticApi extends BaseAPI {
  /**
   * Add TestCase items to the TestCaseStatic test_cases \"to-many\" relationship
   * @summary Add TestCase items to test_cases
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public addTestCaseitemstotestcases0(
    testCaseStaticId: string,
    testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .addTestCaseitemstotestcases0(testCaseStaticId, testCaseStaticTestCasesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add TestSuiteStatic items to the TestCaseStatic test_suite_static \"to-one\" relationship
   * @summary Add TestSuiteStatic items to test_suite_static
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public addTestSuiteStaticitemstotestsuitestatic0(
    testCaseStaticId: string,
    testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .addTestSuiteStaticitemstotestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create TestCaseStatic
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestCaseStaticPostInst1} pOSTBody TestCaseStatic attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public createTestCaseStatic0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: TestCaseStaticPostInst1,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .createTestCaseStatic0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete TestCaseStatic from TestCaseStatic
   * @param {string} testCaseStaticId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public deleteTestCaseStaticfromTestCaseStatic0(
    testCaseStaticId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .deleteTestCaseStaticfromTestCaseStatic0(testCaseStaticId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
   * @summary Delete TestCase from test_cases
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {TestCaseStaticTestCasesRelationship1} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public deleteTestCasefromtestcases0(
    testCaseStaticId: string,
    testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship1,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .deleteTestCasefromtestcases0(testCaseStaticId, testCaseStaticTestCasesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
   * @summary Delete TestSuiteStatic from test_suite_static
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {TestCaseStaticTestSuiteStaticRelationship1} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public deleteTestSuiteStaticfromtestsuitestatic0(
    testCaseStaticId: string,
    testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship1,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .deleteTestSuiteStaticfromtestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCaseStatic from TestCaseStatic
   * @summary Retrieve a collection of TestCaseStatic objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestCaseStatic relationships to include (csv)
   * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterDescription] description attribute filter (csv)
   * @param {string} [filterClassname] classname attribute filter (csv)
   * @param {string} [filterGroup] group attribute filter (csv)
   * @param {string} [filterFile] file attribute filter (csv)
   * @param {string} [filterLine] line attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCaseStatic filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public retrieveTestCaseStaticinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestCaseStatic?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterName?: string,
    filterDescription?: string,
    filterClassname?: string,
    filterGroup?: string,
    filterFile?: string,
    filterLine?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .retrieveTestCaseStaticinstance0(
        contentType,
        include,
        fieldsTestCaseStatic,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterName,
        filterDescription,
        filterClassname,
        filterGroup,
        filterFile,
        filterLine,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCaseStatic from TestCaseStatic
   * @summary Retrieve TestCaseStatic instance
   * @param {string} testCaseStaticId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestCaseStatic relationships to include (csv)
   * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public retrieveTestCaseStaticinstance1(
    testCaseStaticId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestCaseStatic?: string,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .retrieveTestCaseStaticinstance1(testCaseStaticId, contentType, include, fieldsTestCaseStatic, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the TestCaseStatic test_cases \"to-many\" relationship
   * @summary Retrieve TestCase from test_cases
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public retrieveTestCasefromtestcases0(
    testCaseStaticId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .retrieveTestCasefromtestcases0(
        testCaseStaticId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuiteStatic items from the TestCaseStatic test_suite_static \"to-one\" relationship
   * @summary Retrieve TestSuiteStatic from test_suite_static
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {string} [include] TestSuiteStatic relationships to include (csv)
   * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterDescription] description attribute filter (csv)
   * @param {string} [filterPackage] package attribute filter (csv)
   * @param {string} [filterGroup] group attribute filter (csv)
   * @param {string} [filterFile] file attribute filter (csv)
   * @param {string} [filterLog] log attribute filter (csv)
   * @param {string} [filterVersion] version attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuiteStatic filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public retrieveTestSuiteStaticfromtestsuitestatic0(
    testCaseStaticId: string,
    include?: string,
    fieldsTestSuiteStatic?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterName?: string,
    filterDescription?: string,
    filterPackage?: string,
    filterGroup?: string,
    filterFile?: string,
    filterLog?: string,
    filterVersion?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .retrieveTestSuiteStaticfromtestsuitestatic0(
        testCaseStaticId,
        include,
        fieldsTestSuiteStatic,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterDescription,
        filterPackage,
        filterGroup,
        filterFile,
        filterLog,
        filterVersion,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update TestCaseStatic attributes
   * @summary Update TestCaseStatic
   * @param {string} testCaseStaticId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestCaseStaticPatchInst} pATCHBody TestCaseStatic attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public updateTestCaseStatic0(
    testCaseStaticId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: TestCaseStaticPatchInst,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .updateTestCaseStatic0(testCaseStaticId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCaseStatic test_cases \"to-many\" relationship
   * @summary Update test_cases
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {TestCaseStaticTestCasesRelationship} testCaseStaticTestCasesBody TestCaseStatic.test_cases POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public updatetestcases0(
    testCaseStaticId: string,
    testCaseStaticTestCasesBody: TestCaseStaticTestCasesRelationship,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .updatetestcases0(testCaseStaticId, testCaseStaticTestCasesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestCaseStatic test_suite_static \"to-one\" relationship
   * @summary Update test_suite_static
   * @param {string} testCaseStaticId TestCaseStatic item
   * @param {TestCaseStaticTestSuiteStaticRelationship} testCaseStaticTestSuiteStaticBody TestCaseStatic.test_suite_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestCaseStaticApi
   */
  public updatetestsuitestatic0(
    testCaseStaticId: string,
    testCaseStaticTestSuiteStaticBody: TestCaseStaticTestSuiteStaticRelationship,
    options?: any
  ) {
    return TestCaseStaticApiFp(this.configuration)
      .updatetestsuitestatic0(testCaseStaticId, testCaseStaticTestSuiteStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TestRunApi - axios parameter creator
 * @export
 */
export const TestRunApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestSuite items to the TestRun test_suites \"to-many\" relationship
     * @summary Add TestSuite items to test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteitemstotestsuites1: async (
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling addTestSuiteitemstotestsuites1.'
        )
      }
      // verify required parameter 'testRunTestSuitesBody' is not null or undefined
      if (testRunTestSuitesBody === null || testRunTestSuitesBody === undefined) {
        throw new RequiredError(
          'testRunTestSuitesBody',
          'Required parameter testRunTestSuitesBody was null or undefined when calling addTestSuiteitemstotestsuites1.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/test_suites`.replace(
        `{${'TestRunId'}}`,
        encodeURIComponent(String(testRunId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testRunTestSuitesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testRunTestSuitesBody !== undefined ? testRunTestSuitesBody : {})
        : testRunTestSuitesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create TestRun
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestRunPostInst1} pOSTBody TestRun attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestRun0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestRunPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createTestRun0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createTestRun0.'
        )
      }
      const localVarPath = `/TestRun/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete TestRun from TestRun
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestRunfromTestRun0: async (
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling deleteTestRunfromTestRun0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteTestRunfromTestRun0.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/`.replace(`{${'TestRunId'}}`, encodeURIComponent(String(testRunId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestSuite items from the TestRun test_suites \"to-many\" relationship
     * @summary Delete TestSuite from test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromtestsuites1: async (
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling deleteTestSuitefromtestsuites1.'
        )
      }
      // verify required parameter 'testRunTestSuitesBody' is not null or undefined
      if (testRunTestSuitesBody === null || testRunTestSuitesBody === undefined) {
        throw new RequiredError(
          'testRunTestSuitesBody',
          'Required parameter testRunTestSuitesBody was null or undefined when calling deleteTestSuitefromtestsuites1.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/test_suites`.replace(
        `{${'TestRunId'}}`,
        encodeURIComponent(String(testRunId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testRunTestSuitesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testRunTestSuitesBody !== undefined ? testRunTestSuitesBody : {})
        : testRunTestSuitesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestRun from TestRun
     * @summary Retrieve a collection of TestRun objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterMeta] meta attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestRun filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestRuninstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestRun?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterTimestamp?: string,
      filterTime?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterSkipped?: string,
      filterMeta?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestRuninstance0.'
        )
      }
      const localVarPath = `/TestRun/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestRun !== undefined) {
        localVarQueryParameter['fields[TestRun]'] = fieldsTestRun
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterTimestamp !== undefined) {
        localVarQueryParameter['filter[timestamp]'] = filterTimestamp
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterTests !== undefined) {
        localVarQueryParameter['filter[tests]'] = filterTests
      }

      if (filterFailures !== undefined) {
        localVarQueryParameter['filter[failures]'] = filterFailures
      }

      if (filterErrors !== undefined) {
        localVarQueryParameter['filter[errors]'] = filterErrors
      }

      if (filterSkipped !== undefined) {
        localVarQueryParameter['filter[skipped]'] = filterSkipped
      }

      if (filterMeta !== undefined) {
        localVarQueryParameter['filter[meta]'] = filterMeta
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestRun from TestRun
     * @summary Retrieve TestRun instance
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestRuninstance1: async (
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestRun?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling retrieveTestRuninstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestRuninstance1.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/`.replace(`{${'TestRunId'}}`, encodeURIComponent(String(testRunId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestRun !== undefined) {
        localVarQueryParameter['fields[TestRun]'] = fieldsTestRun
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuite items from the TestRun test_suites \"to-many\" relationship
     * @summary Retrieve TestSuite from test_suites
     * @param {string} testRunId TestRun item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuitefromtestsuites1: async (
      testRunId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling retrieveTestSuitefromtestsuites1.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/test_suites`.replace(
        `{${'TestRunId'}}`,
        encodeURIComponent(String(testRunId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuite !== undefined) {
        localVarQueryParameter['fields[TestSuite]'] = fieldsTestSuite
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterTestRunId !== undefined) {
        localVarQueryParameter['filter[test_run_id]'] = filterTestRunId
      }

      if (filterTests !== undefined) {
        localVarQueryParameter['filter[tests]'] = filterTests
      }

      if (filterFailures !== undefined) {
        localVarQueryParameter['filter[failures]'] = filterFailures
      }

      if (filterErrors !== undefined) {
        localVarQueryParameter['filter[errors]'] = filterErrors
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterSkipped !== undefined) {
        localVarQueryParameter['filter[skipped]'] = filterSkipped
      }

      if (filterTimestamp !== undefined) {
        localVarQueryParameter['filter[timestamp]'] = filterTimestamp
      }

      if (filterHostname !== undefined) {
        localVarQueryParameter['filter[hostname]'] = filterHostname
      }

      if (filterUrl !== undefined) {
        localVarQueryParameter['filter[url]'] = filterUrl
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update TestRun attributes
     * @summary Update TestRun
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestRunPatchInst} pATCHBody TestRun attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestRun0: async (
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestRunPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling updateTestRun0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateTestRun0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateTestRun0.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/`.replace(`{${'TestRunId'}}`, encodeURIComponent(String(testRunId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestRun test_suites \"to-many\" relationship
     * @summary Update test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuites1: async (
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testRunId' is not null or undefined
      if (testRunId === null || testRunId === undefined) {
        throw new RequiredError(
          'testRunId',
          'Required parameter testRunId was null or undefined when calling updatetestsuites1.'
        )
      }
      // verify required parameter 'testRunTestSuitesBody' is not null or undefined
      if (testRunTestSuitesBody === null || testRunTestSuitesBody === undefined) {
        throw new RequiredError(
          'testRunTestSuitesBody',
          'Required parameter testRunTestSuitesBody was null or undefined when calling updatetestsuites1.'
        )
      }
      const localVarPath = `/TestRun/{TestRunId}/test_suites`.replace(
        `{${'TestRunId'}}`,
        encodeURIComponent(String(testRunId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testRunTestSuitesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testRunTestSuitesBody !== undefined ? testRunTestSuitesBody : {})
        : testRunTestSuitesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TestRunApi - functional programming interface
 * @export
 */
export const TestRunApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestSuite items to the TestRun test_suites \"to-many\" relationship
     * @summary Add TestSuite items to test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestSuiteitemstotestsuites1(
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).addTestSuiteitemstotestsuites1(
        testRunId,
        testRunTestSuitesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create TestRun
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestRunPostInst1} pOSTBody TestRun attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTestRun0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestRunPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).createTestRun0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete TestRun from TestRun
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestRunfromTestRun0(
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).deleteTestRunfromTestRun0(
        testRunId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestSuite items from the TestRun test_suites \"to-many\" relationship
     * @summary Delete TestSuite from test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuitefromtestsuites1(
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).deleteTestSuitefromtestsuites1(
        testRunId,
        testRunTestSuitesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestRun from TestRun
     * @summary Retrieve a collection of TestRun objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterMeta] meta attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestRun filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestRuninstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestRun?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterTimestamp?: string,
      filterTime?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterSkipped?: string,
      filterMeta?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRunGetColl>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).retrieveTestRuninstance0(
        contentType,
        include,
        fieldsTestRun,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterTimestamp,
        filterTime,
        filterTests,
        filterFailures,
        filterErrors,
        filterSkipped,
        filterMeta,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestRun from TestRun
     * @summary Retrieve TestRun instance
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestRuninstance1(
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestRun?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).retrieveTestRuninstance1(
        testRunId,
        contentType,
        include,
        fieldsTestRun,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuite items from the TestRun test_suites \"to-many\" relationship
     * @summary Retrieve TestSuite from test_suites
     * @param {string} testRunId TestRun item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuitefromtestsuites1(
      testRunId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).retrieveTestSuitefromtestsuites1(
        testRunId,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update TestRun attributes
     * @summary Update TestRun
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestRunPatchInst} pATCHBody TestRun attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTestRun0(
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestRunPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).updateTestRun0(
        testRunId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestRun test_suites \"to-many\" relationship
     * @summary Update test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestsuites1(
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestRunApiAxiosParamCreator(configuration).updatetestsuites1(
        testRunId,
        testRunTestSuitesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TestRunApi - factory interface
 * @export
 */
export const TestRunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestSuite items to the TestRun test_suites \"to-many\" relationship
     * @summary Add TestSuite items to test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteitemstotestsuites1(
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .addTestSuiteitemstotestsuites1(testRunId, testRunTestSuitesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create TestRun
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestRunPostInst1} pOSTBody TestRun attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestRun0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestRunPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .createTestRun0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete TestRun from TestRun
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestRunfromTestRun0(
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .deleteTestRunfromTestRun0(testRunId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestSuite items from the TestRun test_suites \"to-many\" relationship
     * @summary Delete TestSuite from test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromtestsuites1(
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .deleteTestSuitefromtestsuites1(testRunId, testRunTestSuitesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestRun from TestRun
     * @summary Retrieve a collection of TestRun objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterMeta] meta attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestRun filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestRuninstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestRun?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterTimestamp?: string,
      filterTime?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterSkipped?: string,
      filterMeta?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<TestRunGetColl> {
      return TestRunApiFp(configuration)
        .retrieveTestRuninstance0(
          contentType,
          include,
          fieldsTestRun,
          pageOffset,
          pageLimit,
          sort,
          filterName,
          filterTimestamp,
          filterTime,
          filterTests,
          filterFailures,
          filterErrors,
          filterSkipped,
          filterMeta,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestRun from TestRun
     * @summary Retrieve TestRun instance
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestRuninstance1(
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestRun?: string,
      options?: any
    ): AxiosPromise<object> {
      return TestRunApiFp(configuration)
        .retrieveTestRuninstance1(testRunId, contentType, include, fieldsTestRun, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuite items from the TestRun test_suites \"to-many\" relationship
     * @summary Retrieve TestSuite from test_suites
     * @param {string} testRunId TestRun item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuitefromtestsuites1(
      testRunId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .retrieveTestSuitefromtestsuites1(
          testRunId,
          include,
          fieldsTestSuite,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterTestRunId,
          filterTests,
          filterFailures,
          filterErrors,
          filterTime,
          filterSkipped,
          filterTimestamp,
          filterHostname,
          filterUrl,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update TestRun attributes
     * @summary Update TestRun
     * @param {string} testRunId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestRunPatchInst} pATCHBody TestRun attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestRun0(
      testRunId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestRunPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .updateTestRun0(testRunId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestRun test_suites \"to-many\" relationship
     * @summary Update test_suites
     * @param {string} testRunId TestRun item
     * @param {TestRunTestSuitesRelationship} testRunTestSuitesBody TestRun.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuites1(
      testRunId: string,
      testRunTestSuitesBody: TestRunTestSuitesRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestRunApiFp(configuration)
        .updatetestsuites1(testRunId, testRunTestSuitesBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TestRunApi - object-oriented interface
 * @export
 * @class TestRunApi
 * @extends {BaseAPI}
 */
export class TestRunApi extends BaseAPI {
  /**
   * Add TestSuite items to the TestRun test_suites \"to-many\" relationship
   * @summary Add TestSuite items to test_suites
   * @param {string} testRunId TestRun item
   * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public addTestSuiteitemstotestsuites1(
    testRunId: string,
    testRunTestSuitesBody: TestRunTestSuitesRelationship1,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .addTestSuiteitemstotestsuites1(testRunId, testRunTestSuitesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create TestRun
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestRunPostInst1} pOSTBody TestRun attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public createTestRun0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: TestRunPostInst1,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .createTestRun0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete TestRun from TestRun
   * @param {string} testRunId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public deleteTestRunfromTestRun0(
    testRunId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .deleteTestRunfromTestRun0(testRunId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestSuite items from the TestRun test_suites \"to-many\" relationship
   * @summary Delete TestSuite from test_suites
   * @param {string} testRunId TestRun item
   * @param {TestRunTestSuitesRelationship1} testRunTestSuitesBody TestRun.test_suites POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public deleteTestSuitefromtestsuites1(
    testRunId: string,
    testRunTestSuitesBody: TestRunTestSuitesRelationship1,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .deleteTestSuitefromtestsuites1(testRunId, testRunTestSuitesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestRun from TestRun
   * @summary Retrieve a collection of TestRun objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestRun relationships to include (csv)
   * @param {string} [fieldsTestRun] TestRun fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterTimestamp] timestamp attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterTests] tests attribute filter (csv)
   * @param {string} [filterFailures] failures attribute filter (csv)
   * @param {string} [filterErrors] errors attribute filter (csv)
   * @param {string} [filterSkipped] skipped attribute filter (csv)
   * @param {string} [filterMeta] meta attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestRun filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public retrieveTestRuninstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestRun?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterName?: string,
    filterTimestamp?: string,
    filterTime?: string,
    filterTests?: string,
    filterFailures?: string,
    filterErrors?: string,
    filterSkipped?: string,
    filterMeta?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .retrieveTestRuninstance0(
        contentType,
        include,
        fieldsTestRun,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterTimestamp,
        filterTime,
        filterTests,
        filterFailures,
        filterErrors,
        filterSkipped,
        filterMeta,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestRun from TestRun
   * @summary Retrieve TestRun instance
   * @param {string} testRunId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestRun relationships to include (csv)
   * @param {string} [fieldsTestRun] TestRun fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public retrieveTestRuninstance1(
    testRunId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestRun?: string,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .retrieveTestRuninstance1(testRunId, contentType, include, fieldsTestRun, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuite items from the TestRun test_suites \"to-many\" relationship
   * @summary Retrieve TestSuite from test_suites
   * @param {string} testRunId TestRun item
   * @param {string} [include] TestSuite relationships to include (csv)
   * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
   * @param {string} [filterTests] tests attribute filter (csv)
   * @param {string} [filterFailures] failures attribute filter (csv)
   * @param {string} [filterErrors] errors attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterSkipped] skipped attribute filter (csv)
   * @param {string} [filterTimestamp] timestamp attribute filter (csv)
   * @param {string} [filterHostname] hostname attribute filter (csv)
   * @param {string} [filterUrl] url attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuite filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public retrieveTestSuitefromtestsuites1(
    testRunId: string,
    include?: string,
    fieldsTestSuite?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterTestRunId?: string,
    filterTests?: string,
    filterFailures?: string,
    filterErrors?: string,
    filterTime?: string,
    filterSkipped?: string,
    filterTimestamp?: string,
    filterHostname?: string,
    filterUrl?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .retrieveTestSuitefromtestsuites1(
        testRunId,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update TestRun attributes
   * @summary Update TestRun
   * @param {string} testRunId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestRunPatchInst} pATCHBody TestRun attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public updateTestRun0(
    testRunId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: TestRunPatchInst,
    options?: any
  ) {
    return TestRunApiFp(this.configuration)
      .updateTestRun0(testRunId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestRun test_suites \"to-many\" relationship
   * @summary Update test_suites
   * @param {string} testRunId TestRun item
   * @param {TestRunTestSuitesRelationship} testRunTestSuitesBody TestRun.test_suites POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestRunApi
   */
  public updatetestsuites1(testRunId: string, testRunTestSuitesBody: TestRunTestSuitesRelationship, options?: any) {
    return TestRunApiFp(this.configuration)
      .updatetestsuites1(testRunId, testRunTestSuitesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TestSuiteApi - axios parameter creator
 * @export
 */
export const TestSuiteApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the TestSuite test_cases \"to-many\" relationship
     * @summary Add TestCase items to test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcases1: async (
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling addTestCaseitemstotestcases1.'
        )
      }
      // verify required parameter 'testSuiteTestCasesBody' is not null or undefined
      if (testSuiteTestCasesBody === null || testSuiteTestCasesBody === undefined) {
        throw new RequiredError(
          'testSuiteTestCasesBody',
          'Required parameter testSuiteTestCasesBody was null or undefined when calling addTestCaseitemstotestcases1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_cases`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestCasesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestCasesBody !== undefined ? testSuiteTestCasesBody : {})
        : testSuiteTestCasesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add TestRun items to the TestSuite test_run \"to-one\" relationship
     * @summary Add TestRun items to test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestRunitemstotestrun0: async (
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling addTestRunitemstotestrun0.'
        )
      }
      // verify required parameter 'testSuiteTestRunBody' is not null or undefined
      if (testSuiteTestRunBody === null || testSuiteTestRunBody === undefined) {
        throw new RequiredError(
          'testSuiteTestRunBody',
          'Required parameter testSuiteTestRunBody was null or undefined when calling addTestRunitemstotestrun0.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_run`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestRunBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestRunBody !== undefined ? testSuiteTestRunBody : {})
        : testSuiteTestRunBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add TestSuiteStatic items to the TestSuite test_suite_static \"to-one\" relationship
     * @summary Add TestSuiteStatic items to test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteStaticitemstotestsuitestatic1: async (
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling addTestSuiteStaticitemstotestsuitestatic1.'
        )
      }
      // verify required parameter 'testSuiteTestSuiteStaticBody' is not null or undefined
      if (testSuiteTestSuiteStaticBody === null || testSuiteTestSuiteStaticBody === undefined) {
        throw new RequiredError(
          'testSuiteTestSuiteStaticBody',
          'Required parameter testSuiteTestSuiteStaticBody was null or undefined when calling addTestSuiteStaticitemstotestsuitestatic1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_suite_static`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestSuiteStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestSuiteStaticBody !== undefined ? testSuiteTestSuiteStaticBody : {})
        : testSuiteTestSuiteStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create TestSuite
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuitePostInst1} pOSTBody TestSuite attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestSuite0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestSuitePostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createTestSuite0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createTestSuite0.'
        )
      }
      const localVarPath = `/TestSuite/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCase items from the TestSuite test_cases \"to-many\" relationship
     * @summary Delete TestCase from test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcases1: async (
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling deleteTestCasefromtestcases1.'
        )
      }
      // verify required parameter 'testSuiteTestCasesBody' is not null or undefined
      if (testSuiteTestCasesBody === null || testSuiteTestCasesBody === undefined) {
        throw new RequiredError(
          'testSuiteTestCasesBody',
          'Required parameter testSuiteTestCasesBody was null or undefined when calling deleteTestCasefromtestcases1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_cases`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestCasesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestCasesBody !== undefined ? testSuiteTestCasesBody : {})
        : testSuiteTestCasesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestRun items from the TestSuite test_run \"to-one\" relationship
     * @summary Delete TestRun from test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestRunfromtestrun0: async (
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling deleteTestRunfromtestrun0.'
        )
      }
      // verify required parameter 'testSuiteTestRunBody' is not null or undefined
      if (testSuiteTestRunBody === null || testSuiteTestRunBody === undefined) {
        throw new RequiredError(
          'testSuiteTestRunBody',
          'Required parameter testSuiteTestRunBody was null or undefined when calling deleteTestRunfromtestrun0.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_run`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestRunBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestRunBody !== undefined ? testSuiteTestRunBody : {})
        : testSuiteTestRunBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
     * @summary Delete TestSuiteStatic from test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuiteStaticfromtestsuitestatic1: async (
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling deleteTestSuiteStaticfromtestsuitestatic1.'
        )
      }
      // verify required parameter 'testSuiteTestSuiteStaticBody' is not null or undefined
      if (testSuiteTestSuiteStaticBody === null || testSuiteTestSuiteStaticBody === undefined) {
        throw new RequiredError(
          'testSuiteTestSuiteStaticBody',
          'Required parameter testSuiteTestSuiteStaticBody was null or undefined when calling deleteTestSuiteStaticfromtestsuitestatic1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_suite_static`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestSuiteStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestSuiteStaticBody !== undefined ? testSuiteTestSuiteStaticBody : {})
        : testSuiteTestSuiteStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete TestSuite from TestSuite
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromTestSuite0: async (
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling deleteTestSuitefromTestSuite0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteTestSuitefromTestSuite0.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCase items from the TestSuite test_cases \"to-many\" relationship
     * @summary Retrieve TestCase from test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcases1: async (
      testSuiteId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling retrieveTestCasefromtestcases1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_cases`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCase !== undefined) {
        localVarQueryParameter['fields[TestCase]'] = fieldsTestCase
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestCaseStaticId !== undefined) {
        localVarQueryParameter['filter[test_case_static_id]'] = filterTestCaseStaticId
      }

      if (filterTestSuiteId !== undefined) {
        localVarQueryParameter['filter[test_suite_id]'] = filterTestSuiteId
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestRun items from the TestSuite test_run \"to-one\" relationship
     * @summary Retrieve TestRun from test_run
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterMeta] meta attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestRun filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestRunfromtestrun0: async (
      testSuiteId: string,
      include?: string,
      fieldsTestRun?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterTimestamp?: string,
      filterTime?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterSkipped?: string,
      filterMeta?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling retrieveTestRunfromtestrun0.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_run`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestRun !== undefined) {
        localVarQueryParameter['fields[TestRun]'] = fieldsTestRun
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterTimestamp !== undefined) {
        localVarQueryParameter['filter[timestamp]'] = filterTimestamp
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterTests !== undefined) {
        localVarQueryParameter['filter[tests]'] = filterTests
      }

      if (filterFailures !== undefined) {
        localVarQueryParameter['filter[failures]'] = filterFailures
      }

      if (filterErrors !== undefined) {
        localVarQueryParameter['filter[errors]'] = filterErrors
      }

      if (filterSkipped !== undefined) {
        localVarQueryParameter['filter[skipped]'] = filterSkipped
      }

      if (filterMeta !== undefined) {
        localVarQueryParameter['filter[meta]'] = filterMeta
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
     * @summary Retrieve TestSuiteStatic from test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticfromtestsuitestatic1: async (
      testSuiteId: string,
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling retrieveTestSuiteStaticfromtestsuitestatic1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_suite_static`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuiteStatic !== undefined) {
        localVarQueryParameter['fields[TestSuiteStatic]'] = fieldsTestSuiteStatic
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterDescription !== undefined) {
        localVarQueryParameter['filter[description]'] = filterDescription
      }

      if (filterPackage !== undefined) {
        localVarQueryParameter['filter[package]'] = filterPackage
      }

      if (filterGroup !== undefined) {
        localVarQueryParameter['filter[group]'] = filterGroup
      }

      if (filterFile !== undefined) {
        localVarQueryParameter['filter[file]'] = filterFile
      }

      if (filterLog !== undefined) {
        localVarQueryParameter['filter[log]'] = filterLog
      }

      if (filterVersion !== undefined) {
        localVarQueryParameter['filter[version]'] = filterVersion
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuite from TestSuite
     * @summary Retrieve a collection of TestSuite objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestSuiteinstance0.'
        )
      }
      const localVarPath = `/TestSuite/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuite !== undefined) {
        localVarQueryParameter['fields[TestSuite]'] = fieldsTestSuite
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterTestRunId !== undefined) {
        localVarQueryParameter['filter[test_run_id]'] = filterTestRunId
      }

      if (filterTests !== undefined) {
        localVarQueryParameter['filter[tests]'] = filterTests
      }

      if (filterFailures !== undefined) {
        localVarQueryParameter['filter[failures]'] = filterFailures
      }

      if (filterErrors !== undefined) {
        localVarQueryParameter['filter[errors]'] = filterErrors
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterSkipped !== undefined) {
        localVarQueryParameter['filter[skipped]'] = filterSkipped
      }

      if (filterTimestamp !== undefined) {
        localVarQueryParameter['filter[timestamp]'] = filterTimestamp
      }

      if (filterHostname !== undefined) {
        localVarQueryParameter['filter[hostname]'] = filterHostname
      }

      if (filterUrl !== undefined) {
        localVarQueryParameter['filter[url]'] = filterUrl
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuite from TestSuite
     * @summary Retrieve TestSuite instance
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteinstance1: async (
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuite?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling retrieveTestSuiteinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestSuiteinstance1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuite !== undefined) {
        localVarQueryParameter['fields[TestSuite]'] = fieldsTestSuite
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update TestSuite attributes
     * @summary Update TestSuite
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuitePatchInst} pATCHBody TestSuite attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestSuite0: async (
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestSuitePatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling updateTestSuite0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateTestSuite0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateTestSuite0.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestSuite test_cases \"to-many\" relationship
     * @summary Update test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcases1: async (
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling updatetestcases1.'
        )
      }
      // verify required parameter 'testSuiteTestCasesBody' is not null or undefined
      if (testSuiteTestCasesBody === null || testSuiteTestCasesBody === undefined) {
        throw new RequiredError(
          'testSuiteTestCasesBody',
          'Required parameter testSuiteTestCasesBody was null or undefined when calling updatetestcases1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_cases`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestCasesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestCasesBody !== undefined ? testSuiteTestCasesBody : {})
        : testSuiteTestCasesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestSuite test_run \"to-one\" relationship
     * @summary Update test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestrun0: async (
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling updatetestrun0.'
        )
      }
      // verify required parameter 'testSuiteTestRunBody' is not null or undefined
      if (testSuiteTestRunBody === null || testSuiteTestRunBody === undefined) {
        throw new RequiredError(
          'testSuiteTestRunBody',
          'Required parameter testSuiteTestRunBody was null or undefined when calling updatetestrun0.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_run`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestRunBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestRunBody !== undefined ? testSuiteTestRunBody : {})
        : testSuiteTestRunBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestSuite test_suite_static \"to-one\" relationship
     * @summary Update test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuitestatic1: async (
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteId' is not null or undefined
      if (testSuiteId === null || testSuiteId === undefined) {
        throw new RequiredError(
          'testSuiteId',
          'Required parameter testSuiteId was null or undefined when calling updatetestsuitestatic1.'
        )
      }
      // verify required parameter 'testSuiteTestSuiteStaticBody' is not null or undefined
      if (testSuiteTestSuiteStaticBody === null || testSuiteTestSuiteStaticBody === undefined) {
        throw new RequiredError(
          'testSuiteTestSuiteStaticBody',
          'Required parameter testSuiteTestSuiteStaticBody was null or undefined when calling updatetestsuitestatic1.'
        )
      }
      const localVarPath = `/TestSuite/{TestSuiteId}/test_suite_static`.replace(
        `{${'TestSuiteId'}}`,
        encodeURIComponent(String(testSuiteId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteTestSuiteStaticBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteTestSuiteStaticBody !== undefined ? testSuiteTestSuiteStaticBody : {})
        : testSuiteTestSuiteStaticBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TestSuiteApi - functional programming interface
 * @export
 */
export const TestSuiteApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCase items to the TestSuite test_cases \"to-many\" relationship
     * @summary Add TestCase items to test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseitemstotestcases1(
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).addTestCaseitemstotestcases1(
        testSuiteId,
        testSuiteTestCasesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add TestRun items to the TestSuite test_run \"to-one\" relationship
     * @summary Add TestRun items to test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestRunitemstotestrun0(
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).addTestRunitemstotestrun0(
        testSuiteId,
        testSuiteTestRunBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add TestSuiteStatic items to the TestSuite test_suite_static \"to-one\" relationship
     * @summary Add TestSuiteStatic items to test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestSuiteStaticitemstotestsuitestatic1(
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(
        configuration
      ).addTestSuiteStaticitemstotestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create TestSuite
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuitePostInst1} pOSTBody TestSuite attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTestSuite0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestSuitePostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).createTestSuite0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCase items from the TestSuite test_cases \"to-many\" relationship
     * @summary Delete TestCase from test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCasefromtestcases1(
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).deleteTestCasefromtestcases1(
        testSuiteId,
        testSuiteTestCasesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestRun items from the TestSuite test_run \"to-one\" relationship
     * @summary Delete TestRun from test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestRunfromtestrun0(
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).deleteTestRunfromtestrun0(
        testSuiteId,
        testSuiteTestRunBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
     * @summary Delete TestSuiteStatic from test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuiteStaticfromtestsuitestatic1(
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(
        configuration
      ).deleteTestSuiteStaticfromtestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete TestSuite from TestSuite
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuitefromTestSuite0(
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).deleteTestSuitefromTestSuite0(
        testSuiteId,
        contentType,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCase items from the TestSuite test_cases \"to-many\" relationship
     * @summary Retrieve TestCase from test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCasefromtestcases1(
      testSuiteId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).retrieveTestCasefromtestcases1(
        testSuiteId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestRun items from the TestSuite test_run \"to-one\" relationship
     * @summary Retrieve TestRun from test_run
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterMeta] meta attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestRun filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestRunfromtestrun0(
      testSuiteId: string,
      include?: string,
      fieldsTestRun?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterTimestamp?: string,
      filterTime?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterSkipped?: string,
      filterMeta?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).retrieveTestRunfromtestrun0(
        testSuiteId,
        include,
        fieldsTestRun,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterTimestamp,
        filterTime,
        filterTests,
        filterFailures,
        filterErrors,
        filterSkipped,
        filterMeta,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
     * @summary Retrieve TestSuiteStatic from test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuiteStaticfromtestsuitestatic1(
      testSuiteId: string,
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(
        configuration
      ).retrieveTestSuiteStaticfromtestsuitestatic1(
        testSuiteId,
        include,
        fieldsTestSuiteStatic,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterDescription,
        filterPackage,
        filterGroup,
        filterFile,
        filterLog,
        filterVersion,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuite from TestSuite
     * @summary Retrieve a collection of TestSuite objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuiteinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuiteGetColl>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).retrieveTestSuiteinstance0(
        contentType,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuite from TestSuite
     * @summary Retrieve TestSuite instance
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuiteinstance1(
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuite?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).retrieveTestSuiteinstance1(
        testSuiteId,
        contentType,
        include,
        fieldsTestSuite,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update TestSuite attributes
     * @summary Update TestSuite
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuitePatchInst} pATCHBody TestSuite attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTestSuite0(
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestSuitePatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).updateTestSuite0(
        testSuiteId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestSuite test_cases \"to-many\" relationship
     * @summary Update test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcases1(
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).updatetestcases1(
        testSuiteId,
        testSuiteTestCasesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestSuite test_run \"to-one\" relationship
     * @summary Update test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestrun0(
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).updatetestrun0(
        testSuiteId,
        testSuiteTestRunBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestSuite test_suite_static \"to-one\" relationship
     * @summary Update test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestsuitestatic1(
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).updatetestsuitestatic1(
        testSuiteId,
        testSuiteTestSuiteStaticBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TestSuiteApi - factory interface
 * @export
 */
export const TestSuiteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Add TestCase items to the TestSuite test_cases \"to-many\" relationship
     * @summary Add TestCase items to test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseitemstotestcases1(
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .addTestCaseitemstotestcases1(testSuiteId, testSuiteTestCasesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add TestRun items to the TestSuite test_run \"to-one\" relationship
     * @summary Add TestRun items to test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestRunitemstotestrun0(
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .addTestRunitemstotestrun0(testSuiteId, testSuiteTestRunBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add TestSuiteStatic items to the TestSuite test_suite_static \"to-one\" relationship
     * @summary Add TestSuiteStatic items to test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteStaticitemstotestsuitestatic1(
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .addTestSuiteStaticitemstotestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create TestSuite
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuitePostInst1} pOSTBody TestSuite attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestSuite0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestSuitePostInst1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .createTestSuite0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCase items from the TestSuite test_cases \"to-many\" relationship
     * @summary Delete TestCase from test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCasefromtestcases1(
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .deleteTestCasefromtestcases1(testSuiteId, testSuiteTestCasesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestRun items from the TestSuite test_run \"to-one\" relationship
     * @summary Delete TestRun from test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestRunfromtestrun0(
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .deleteTestRunfromtestrun0(testSuiteId, testSuiteTestRunBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
     * @summary Delete TestSuiteStatic from test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuiteStaticfromtestsuitestatic1(
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .deleteTestSuiteStaticfromtestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete TestSuite from TestSuite
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromTestSuite0(
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .deleteTestSuitefromTestSuite0(testSuiteId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCase items from the TestSuite test_cases \"to-many\" relationship
     * @summary Retrieve TestCase from test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestCase relationships to include (csv)
     * @param {string} [fieldsTestCase] TestCase fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
     * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCase filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCasefromtestcases1(
      testSuiteId: string,
      include?: string,
      fieldsTestCase?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestCaseStaticId?: string,
      filterTestSuiteId?: string,
      filterTime?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .retrieveTestCasefromtestcases1(
          testSuiteId,
          include,
          fieldsTestCase,
          pageOffset,
          pageLimit,
          sort,
          filterTestCaseStaticId,
          filterTestSuiteId,
          filterTime,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestRun items from the TestSuite test_run \"to-one\" relationship
     * @summary Retrieve TestRun from test_run
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestRun relationships to include (csv)
     * @param {string} [fieldsTestRun] TestRun fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterMeta] meta attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestRun filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestRunfromtestrun0(
      testSuiteId: string,
      include?: string,
      fieldsTestRun?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterTimestamp?: string,
      filterTime?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterSkipped?: string,
      filterMeta?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .retrieveTestRunfromtestrun0(
          testSuiteId,
          include,
          fieldsTestRun,
          pageOffset,
          pageLimit,
          sort,
          filterName,
          filterTimestamp,
          filterTime,
          filterTests,
          filterFailures,
          filterErrors,
          filterSkipped,
          filterMeta,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
     * @summary Retrieve TestSuiteStatic from test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticfromtestsuitestatic1(
      testSuiteId: string,
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .retrieveTestSuiteStaticfromtestsuitestatic1(
          testSuiteId,
          include,
          fieldsTestSuiteStatic,
          pageOffset,
          pageLimit,
          sort,
          filterName,
          filterDescription,
          filterPackage,
          filterGroup,
          filterFile,
          filterLog,
          filterVersion,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuite from TestSuite
     * @summary Retrieve a collection of TestSuite objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<TestSuiteGetColl> {
      return TestSuiteApiFp(configuration)
        .retrieveTestSuiteinstance0(
          contentType,
          include,
          fieldsTestSuite,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterTestRunId,
          filterTests,
          filterFailures,
          filterErrors,
          filterTime,
          filterSkipped,
          filterTimestamp,
          filterHostname,
          filterUrl,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuite from TestSuite
     * @summary Retrieve TestSuite instance
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteinstance1(
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuite?: string,
      options?: any
    ): AxiosPromise<object> {
      return TestSuiteApiFp(configuration)
        .retrieveTestSuiteinstance1(testSuiteId, contentType, include, fieldsTestSuite, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update TestSuite attributes
     * @summary Update TestSuite
     * @param {string} testSuiteId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuitePatchInst} pATCHBody TestSuite attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestSuite0(
      testSuiteId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestSuitePatchInst,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .updateTestSuite0(testSuiteId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestSuite test_cases \"to-many\" relationship
     * @summary Update test_cases
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestCasesRelationship} testSuiteTestCasesBody TestSuite.test_cases POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcases1(
      testSuiteId: string,
      testSuiteTestCasesBody: TestSuiteTestCasesRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .updatetestcases1(testSuiteId, testSuiteTestCasesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestSuite test_run \"to-one\" relationship
     * @summary Update test_run
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestRunRelationship} testSuiteTestRunBody TestSuite.test_run POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestrun0(
      testSuiteId: string,
      testSuiteTestRunBody: TestSuiteTestRunRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .updatetestrun0(testSuiteId, testSuiteTestRunBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestSuite test_suite_static \"to-one\" relationship
     * @summary Update test_suite_static
     * @param {string} testSuiteId TestSuite item
     * @param {TestSuiteTestSuiteStaticRelationship} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuitestatic1(
      testSuiteId: string,
      testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteApiFp(configuration)
        .updatetestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TestSuiteApi - object-oriented interface
 * @export
 * @class TestSuiteApi
 * @extends {BaseAPI}
 */
export class TestSuiteApi extends BaseAPI {
  /**
   * Add TestCase items to the TestSuite test_cases \"to-many\" relationship
   * @summary Add TestCase items to test_cases
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public addTestCaseitemstotestcases1(
    testSuiteId: string,
    testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .addTestCaseitemstotestcases1(testSuiteId, testSuiteTestCasesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add TestRun items to the TestSuite test_run \"to-one\" relationship
   * @summary Add TestRun items to test_run
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public addTestRunitemstotestrun0(
    testSuiteId: string,
    testSuiteTestRunBody: TestSuiteTestRunRelationship1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .addTestRunitemstotestrun0(testSuiteId, testSuiteTestRunBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add TestSuiteStatic items to the TestSuite test_suite_static \"to-one\" relationship
   * @summary Add TestSuiteStatic items to test_suite_static
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public addTestSuiteStaticitemstotestsuitestatic1(
    testSuiteId: string,
    testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .addTestSuiteStaticitemstotestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create TestSuite
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestSuitePostInst1} pOSTBody TestSuite attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public createTestSuite0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: TestSuitePostInst1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .createTestSuite0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCase items from the TestSuite test_cases \"to-many\" relationship
   * @summary Delete TestCase from test_cases
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestCasesRelationship1} testSuiteTestCasesBody TestSuite.test_cases POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public deleteTestCasefromtestcases1(
    testSuiteId: string,
    testSuiteTestCasesBody: TestSuiteTestCasesRelationship1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .deleteTestCasefromtestcases1(testSuiteId, testSuiteTestCasesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestRun items from the TestSuite test_run \"to-one\" relationship
   * @summary Delete TestRun from test_run
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestRunRelationship1} testSuiteTestRunBody TestSuite.test_run POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public deleteTestRunfromtestrun0(
    testSuiteId: string,
    testSuiteTestRunBody: TestSuiteTestRunRelationship1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .deleteTestRunfromtestrun0(testSuiteId, testSuiteTestRunBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
   * @summary Delete TestSuiteStatic from test_suite_static
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestSuiteStaticRelationship1} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public deleteTestSuiteStaticfromtestsuitestatic1(
    testSuiteId: string,
    testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship1,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .deleteTestSuiteStaticfromtestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete TestSuite from TestSuite
   * @param {string} testSuiteId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public deleteTestSuitefromTestSuite0(
    testSuiteId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .deleteTestSuitefromTestSuite0(testSuiteId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCase items from the TestSuite test_cases \"to-many\" relationship
   * @summary Retrieve TestCase from test_cases
   * @param {string} testSuiteId TestSuite item
   * @param {string} [include] TestCase relationships to include (csv)
   * @param {string} [fieldsTestCase] TestCase fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestCaseStaticId] test_case_static_id attribute filter (csv)
   * @param {string} [filterTestSuiteId] test_suite_id attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCase filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public retrieveTestCasefromtestcases1(
    testSuiteId: string,
    include?: string,
    fieldsTestCase?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestCaseStaticId?: string,
    filterTestSuiteId?: string,
    filterTime?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .retrieveTestCasefromtestcases1(
        testSuiteId,
        include,
        fieldsTestCase,
        pageOffset,
        pageLimit,
        sort,
        filterTestCaseStaticId,
        filterTestSuiteId,
        filterTime,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestRun items from the TestSuite test_run \"to-one\" relationship
   * @summary Retrieve TestRun from test_run
   * @param {string} testSuiteId TestSuite item
   * @param {string} [include] TestRun relationships to include (csv)
   * @param {string} [fieldsTestRun] TestRun fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterTimestamp] timestamp attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterTests] tests attribute filter (csv)
   * @param {string} [filterFailures] failures attribute filter (csv)
   * @param {string} [filterErrors] errors attribute filter (csv)
   * @param {string} [filterSkipped] skipped attribute filter (csv)
   * @param {string} [filterMeta] meta attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestRun filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public retrieveTestRunfromtestrun0(
    testSuiteId: string,
    include?: string,
    fieldsTestRun?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterName?: string,
    filterTimestamp?: string,
    filterTime?: string,
    filterTests?: string,
    filterFailures?: string,
    filterErrors?: string,
    filterSkipped?: string,
    filterMeta?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .retrieveTestRunfromtestrun0(
        testSuiteId,
        include,
        fieldsTestRun,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterTimestamp,
        filterTime,
        filterTests,
        filterFailures,
        filterErrors,
        filterSkipped,
        filterMeta,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuiteStatic items from the TestSuite test_suite_static \"to-one\" relationship
   * @summary Retrieve TestSuiteStatic from test_suite_static
   * @param {string} testSuiteId TestSuite item
   * @param {string} [include] TestSuiteStatic relationships to include (csv)
   * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterDescription] description attribute filter (csv)
   * @param {string} [filterPackage] package attribute filter (csv)
   * @param {string} [filterGroup] group attribute filter (csv)
   * @param {string} [filterFile] file attribute filter (csv)
   * @param {string} [filterLog] log attribute filter (csv)
   * @param {string} [filterVersion] version attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuiteStatic filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public retrieveTestSuiteStaticfromtestsuitestatic1(
    testSuiteId: string,
    include?: string,
    fieldsTestSuiteStatic?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterName?: string,
    filterDescription?: string,
    filterPackage?: string,
    filterGroup?: string,
    filterFile?: string,
    filterLog?: string,
    filterVersion?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .retrieveTestSuiteStaticfromtestsuitestatic1(
        testSuiteId,
        include,
        fieldsTestSuiteStatic,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterDescription,
        filterPackage,
        filterGroup,
        filterFile,
        filterLog,
        filterVersion,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuite from TestSuite
   * @summary Retrieve a collection of TestSuite objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestSuite relationships to include (csv)
   * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
   * @param {string} [filterTests] tests attribute filter (csv)
   * @param {string} [filterFailures] failures attribute filter (csv)
   * @param {string} [filterErrors] errors attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterSkipped] skipped attribute filter (csv)
   * @param {string} [filterTimestamp] timestamp attribute filter (csv)
   * @param {string} [filterHostname] hostname attribute filter (csv)
   * @param {string} [filterUrl] url attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuite filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public retrieveTestSuiteinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestSuite?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterTestRunId?: string,
    filterTests?: string,
    filterFailures?: string,
    filterErrors?: string,
    filterTime?: string,
    filterSkipped?: string,
    filterTimestamp?: string,
    filterHostname?: string,
    filterUrl?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .retrieveTestSuiteinstance0(
        contentType,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuite from TestSuite
   * @summary Retrieve TestSuite instance
   * @param {string} testSuiteId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestSuite relationships to include (csv)
   * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public retrieveTestSuiteinstance1(
    testSuiteId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestSuite?: string,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .retrieveTestSuiteinstance1(testSuiteId, contentType, include, fieldsTestSuite, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update TestSuite attributes
   * @summary Update TestSuite
   * @param {string} testSuiteId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestSuitePatchInst} pATCHBody TestSuite attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public updateTestSuite0(
    testSuiteId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: TestSuitePatchInst,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .updateTestSuite0(testSuiteId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestSuite test_cases \"to-many\" relationship
   * @summary Update test_cases
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestCasesRelationship} testSuiteTestCasesBody TestSuite.test_cases POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public updatetestcases1(testSuiteId: string, testSuiteTestCasesBody: TestSuiteTestCasesRelationship, options?: any) {
    return TestSuiteApiFp(this.configuration)
      .updatetestcases1(testSuiteId, testSuiteTestCasesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestSuite test_run \"to-one\" relationship
   * @summary Update test_run
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestRunRelationship} testSuiteTestRunBody TestSuite.test_run POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public updatetestrun0(testSuiteId: string, testSuiteTestRunBody: TestSuiteTestRunRelationship, options?: any) {
    return TestSuiteApiFp(this.configuration)
      .updatetestrun0(testSuiteId, testSuiteTestRunBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestSuite test_suite_static \"to-one\" relationship
   * @summary Update test_suite_static
   * @param {string} testSuiteId TestSuite item
   * @param {TestSuiteTestSuiteStaticRelationship} testSuiteTestSuiteStaticBody TestSuite.test_suite_static POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteApi
   */
  public updatetestsuitestatic1(
    testSuiteId: string,
    testSuiteTestSuiteStaticBody: TestSuiteTestSuiteStaticRelationship,
    options?: any
  ) {
    return TestSuiteApiFp(this.configuration)
      .updatetestsuitestatic1(testSuiteId, testSuiteTestSuiteStaticBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TestSuiteStaticApi - axios parameter creator
 * @export
 */
export const TestSuiteStaticApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCaseStatic items to the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Add TestCaseStatic items to test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseStaticitemstotestcasestatics0: async (
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling addTestCaseStaticitemstotestcasestatics0.'
        )
      }
      // verify required parameter 'testSuiteStaticTestCaseStaticsBody' is not null or undefined
      if (testSuiteStaticTestCaseStaticsBody === null || testSuiteStaticTestCaseStaticsBody === undefined) {
        throw new RequiredError(
          'testSuiteStaticTestCaseStaticsBody',
          'Required parameter testSuiteStaticTestCaseStaticsBody was null or undefined when calling addTestCaseStaticitemstotestcasestatics0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_case_statics`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteStaticTestCaseStaticsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteStaticTestCaseStaticsBody !== undefined ? testSuiteStaticTestCaseStaticsBody : {})
        : testSuiteStaticTestCaseStaticsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Add TestSuite items to the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Add TestSuite items to test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteitemstotestsuites0: async (
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling addTestSuiteitemstotestsuites0.'
        )
      }
      // verify required parameter 'testSuiteStaticTestSuitesBody' is not null or undefined
      if (testSuiteStaticTestSuitesBody === null || testSuiteStaticTestSuitesBody === undefined) {
        throw new RequiredError(
          'testSuiteStaticTestSuitesBody',
          'Required parameter testSuiteStaticTestSuitesBody was null or undefined when calling addTestSuiteitemstotestsuites0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_suites`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteStaticTestSuitesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteStaticTestSuitesBody !== undefined ? testSuiteStaticTestSuitesBody : {})
        : testSuiteStaticTestSuitesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create TestSuiteStatic
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuiteStaticPostInst1} pOSTBody TestSuiteStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestSuiteStatic0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestSuiteStaticPostInst1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling createTestSuiteStatic0.'
        )
      }
      // verify required parameter 'pOSTBody' is not null or undefined
      if (pOSTBody === null || pOSTBody === undefined) {
        throw new RequiredError(
          'pOSTBody',
          'Required parameter pOSTBody was null or undefined when calling createTestSuiteStatic0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pOSTBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pOSTBody !== undefined ? pOSTBody : {})
        : pOSTBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Delete TestCaseStatic from test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCaseStaticfromtestcasestatics0: async (
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling deleteTestCaseStaticfromtestcasestatics0.'
        )
      }
      // verify required parameter 'testSuiteStaticTestCaseStaticsBody' is not null or undefined
      if (testSuiteStaticTestCaseStaticsBody === null || testSuiteStaticTestCaseStaticsBody === undefined) {
        throw new RequiredError(
          'testSuiteStaticTestCaseStaticsBody',
          'Required parameter testSuiteStaticTestCaseStaticsBody was null or undefined when calling deleteTestCaseStaticfromtestcasestatics0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_case_statics`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteStaticTestCaseStaticsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteStaticTestCaseStaticsBody !== undefined ? testSuiteStaticTestCaseStaticsBody : {})
        : testSuiteStaticTestCaseStaticsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete TestSuiteStatic from TestSuiteStatic
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuiteStaticfromTestSuiteStatic0: async (
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling deleteTestSuiteStaticfromTestSuiteStatic0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteTestSuiteStaticfromTestSuiteStatic0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Delete TestSuite from test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromtestsuites0: async (
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling deleteTestSuitefromtestsuites0.'
        )
      }
      // verify required parameter 'testSuiteStaticTestSuitesBody' is not null or undefined
      if (testSuiteStaticTestSuitesBody === null || testSuiteStaticTestSuitesBody === undefined) {
        throw new RequiredError(
          'testSuiteStaticTestSuitesBody',
          'Required parameter testSuiteStaticTestSuitesBody was null or undefined when calling deleteTestSuitefromtestsuites0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_suites`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteStaticTestSuitesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteStaticTestSuitesBody !== undefined ? testSuiteStaticTestSuitesBody : {})
        : testSuiteStaticTestSuitesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Retrieve TestCaseStatic from test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticfromtestcasestatics0: async (
      testSuiteStaticId: string,
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling retrieveTestCaseStaticfromtestcasestatics0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_case_statics`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestCaseStatic !== undefined) {
        localVarQueryParameter['fields[TestCaseStatic]'] = fieldsTestCaseStatic
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterDescription !== undefined) {
        localVarQueryParameter['filter[description]'] = filterDescription
      }

      if (filterClassname !== undefined) {
        localVarQueryParameter['filter[classname]'] = filterClassname
      }

      if (filterGroup !== undefined) {
        localVarQueryParameter['filter[group]'] = filterGroup
      }

      if (filterFile !== undefined) {
        localVarQueryParameter['filter[file]'] = filterFile
      }

      if (filterLine !== undefined) {
        localVarQueryParameter['filter[line]'] = filterLine
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuiteStatic from TestSuiteStatic
     * @summary Retrieve a collection of TestSuiteStatic objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticinstance0: async (
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestSuiteStaticinstance0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuiteStatic !== undefined) {
        localVarQueryParameter['fields[TestSuiteStatic]'] = fieldsTestSuiteStatic
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName
      }

      if (filterDescription !== undefined) {
        localVarQueryParameter['filter[description]'] = filterDescription
      }

      if (filterPackage !== undefined) {
        localVarQueryParameter['filter[package]'] = filterPackage
      }

      if (filterGroup !== undefined) {
        localVarQueryParameter['filter[group]'] = filterGroup
      }

      if (filterFile !== undefined) {
        localVarQueryParameter['filter[file]'] = filterFile
      }

      if (filterLog !== undefined) {
        localVarQueryParameter['filter[log]'] = filterLog
      }

      if (filterVersion !== undefined) {
        localVarQueryParameter['filter[version]'] = filterVersion
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuiteStatic from TestSuiteStatic
     * @summary Retrieve TestSuiteStatic instance
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticinstance1: async (
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuiteStatic?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling retrieveTestSuiteStaticinstance1.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling retrieveTestSuiteStaticinstance1.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuiteStatic !== undefined) {
        localVarQueryParameter['fields[TestSuiteStatic]'] = fieldsTestSuiteStatic
      }

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Retrieve TestSuite from test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuitefromtestsuites0: async (
      testSuiteStaticId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling retrieveTestSuitefromtestsuites0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_suites`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (include !== undefined) {
        localVarQueryParameter['include'] = include
      }

      if (fieldsTestSuite !== undefined) {
        localVarQueryParameter['fields[TestSuite]'] = fieldsTestSuite
      }

      if (pageOffset !== undefined) {
        localVarQueryParameter['page[offset]'] = pageOffset
      }

      if (pageLimit !== undefined) {
        localVarQueryParameter['page[limit]'] = pageLimit
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (filterTestSuiteStaticId !== undefined) {
        localVarQueryParameter['filter[test_suite_static_id]'] = filterTestSuiteStaticId
      }

      if (filterTestRunId !== undefined) {
        localVarQueryParameter['filter[test_run_id]'] = filterTestRunId
      }

      if (filterTests !== undefined) {
        localVarQueryParameter['filter[tests]'] = filterTests
      }

      if (filterFailures !== undefined) {
        localVarQueryParameter['filter[failures]'] = filterFailures
      }

      if (filterErrors !== undefined) {
        localVarQueryParameter['filter[errors]'] = filterErrors
      }

      if (filterTime !== undefined) {
        localVarQueryParameter['filter[time]'] = filterTime
      }

      if (filterSkipped !== undefined) {
        localVarQueryParameter['filter[skipped]'] = filterSkipped
      }

      if (filterTimestamp !== undefined) {
        localVarQueryParameter['filter[timestamp]'] = filterTimestamp
      }

      if (filterHostname !== undefined) {
        localVarQueryParameter['filter[hostname]'] = filterHostname
      }

      if (filterUrl !== undefined) {
        localVarQueryParameter['filter[url]'] = filterUrl
      }

      if (filterProperties !== undefined) {
        localVarQueryParameter['filter[properties]'] = filterProperties
      }

      if (filterSystemOut !== undefined) {
        localVarQueryParameter['filter[system_out]'] = filterSystemOut
      }

      if (filterSystemErr !== undefined) {
        localVarQueryParameter['filter[system_err]'] = filterSystemErr
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update TestSuiteStatic attributes
     * @summary Update TestSuiteStatic
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuiteStaticPatchInst} pATCHBody TestSuiteStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestSuiteStatic0: async (
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestSuiteStaticPatchInst,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling updateTestSuiteStatic0.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling updateTestSuiteStatic0.'
        )
      }
      // verify required parameter 'pATCHBody' is not null or undefined
      if (pATCHBody === null || pATCHBody === undefined) {
        throw new RequiredError(
          'pATCHBody',
          'Required parameter pATCHBody was null or undefined when calling updateTestSuiteStatic0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof pATCHBody !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(pATCHBody !== undefined ? pATCHBody : {})
        : pATCHBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Update test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcasestatics0: async (
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling updatetestcasestatics0.'
        )
      }
      // verify required parameter 'testSuiteStaticTestCaseStaticsBody' is not null or undefined
      if (testSuiteStaticTestCaseStaticsBody === null || testSuiteStaticTestCaseStaticsBody === undefined) {
        throw new RequiredError(
          'testSuiteStaticTestCaseStaticsBody',
          'Required parameter testSuiteStaticTestCaseStaticsBody was null or undefined when calling updatetestcasestatics0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_case_statics`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteStaticTestCaseStaticsBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteStaticTestCaseStaticsBody !== undefined ? testSuiteStaticTestCaseStaticsBody : {})
        : testSuiteStaticTestCaseStaticsBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Update test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuites0: async (
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testSuiteStaticId' is not null or undefined
      if (testSuiteStaticId === null || testSuiteStaticId === undefined) {
        throw new RequiredError(
          'testSuiteStaticId',
          'Required parameter testSuiteStaticId was null or undefined when calling updatetestsuites0.'
        )
      }
      // verify required parameter 'testSuiteStaticTestSuitesBody' is not null or undefined
      if (testSuiteStaticTestSuitesBody === null || testSuiteStaticTestSuitesBody === undefined) {
        throw new RequiredError(
          'testSuiteStaticTestSuitesBody',
          'Required parameter testSuiteStaticTestSuitesBody was null or undefined when calling updatetestsuites0.'
        )
      }
      const localVarPath = `/TestSuiteStatic/{TestSuiteStaticId}/test_suites`.replace(
        `{${'TestSuiteStaticId'}}`,
        encodeURIComponent(String(testSuiteStaticId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization =
        typeof testSuiteStaticTestSuitesBody !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testSuiteStaticTestSuitesBody !== undefined ? testSuiteStaticTestSuitesBody : {})
        : testSuiteStaticTestSuitesBody || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TestSuiteStaticApi - functional programming interface
 * @export
 */
export const TestSuiteStaticApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add TestCaseStatic items to the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Add TestCaseStatic items to test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestCaseStaticitemstotestcasestatics0(
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).addTestCaseStaticitemstotestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Add TestSuite items to the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Add TestSuite items to test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestSuiteitemstotestsuites0(
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(configuration).addTestSuiteitemstotestsuites0(
        testSuiteStaticId,
        testSuiteStaticTestSuitesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create TestSuiteStatic
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuiteStaticPostInst1} pOSTBody TestSuiteStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTestSuiteStatic0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestSuiteStaticPostInst1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(configuration).createTestSuiteStatic0(
        contentType,
        pOSTBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Delete TestCaseStatic from test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestCaseStaticfromtestcasestatics0(
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).deleteTestCaseStaticfromtestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete TestSuiteStatic from TestSuiteStatic
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuiteStaticfromTestSuiteStatic0(
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).deleteTestSuiteStaticfromTestSuiteStatic0(testSuiteStaticId, contentType, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Delete TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Delete TestSuite from test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTestSuitefromtestsuites0(
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(configuration).deleteTestSuitefromtestsuites0(
        testSuiteStaticId,
        testSuiteStaticTestSuitesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Retrieve TestCaseStatic from test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestCaseStaticfromtestcasestatics0(
      testSuiteStaticId: string,
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).retrieveTestCaseStaticfromtestcasestatics0(
        testSuiteStaticId,
        include,
        fieldsTestCaseStatic,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterName,
        filterDescription,
        filterClassname,
        filterGroup,
        filterFile,
        filterLine,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuiteStatic from TestSuiteStatic
     * @summary Retrieve a collection of TestSuiteStatic objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuiteStaticinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuiteStaticGetColl>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).retrieveTestSuiteStaticinstance0(
        contentType,
        include,
        fieldsTestSuiteStatic,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterDescription,
        filterPackage,
        filterGroup,
        filterFile,
        filterLog,
        filterVersion,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuiteStatic from TestSuiteStatic
     * @summary Retrieve TestSuiteStatic instance
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuiteStaticinstance1(
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuiteStatic?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).retrieveTestSuiteStaticinstance1(testSuiteStaticId, contentType, include, fieldsTestSuiteStatic, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Retrieve TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Retrieve TestSuite from test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveTestSuitefromtestsuites0(
      testSuiteStaticId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(
        configuration
      ).retrieveTestSuitefromtestsuites0(
        testSuiteStaticId,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update TestSuiteStatic attributes
     * @summary Update TestSuiteStatic
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuiteStaticPatchInst} pATCHBody TestSuiteStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTestSuiteStatic0(
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestSuiteStaticPatchInst,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(configuration).updateTestSuiteStatic0(
        testSuiteStaticId,
        contentType,
        pATCHBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Update test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestcasestatics0(
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(configuration).updatetestcasestatics0(
        testSuiteStaticId,
        testSuiteStaticTestCaseStaticsBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Update the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Update test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatetestsuites0(
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await TestSuiteStaticApiAxiosParamCreator(configuration).updatetestsuites0(
        testSuiteStaticId,
        testSuiteStaticTestSuitesBody,
        options
      )
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TestSuiteStaticApi - factory interface
 * @export
 */
export const TestSuiteStaticApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Add TestCaseStatic items to the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Add TestCaseStatic items to test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestCaseStaticitemstotestcasestatics0(
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .addTestCaseStaticitemstotestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Add TestSuite items to the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Add TestSuite items to test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuiteitemstotestsuites0(
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .addTestSuiteitemstotestsuites0(testSuiteStaticId, testSuiteStaticTestSuitesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create TestSuiteStatic
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuiteStaticPostInst1} pOSTBody TestSuiteStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestSuiteStatic0(
      contentType: 'application/vnd.api+json' | 'application/json',
      pOSTBody: TestSuiteStaticPostInst1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .createTestSuiteStatic0(contentType, pOSTBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Delete TestCaseStatic from test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestCaseStaticfromtestcasestatics0(
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .deleteTestCaseStaticfromtestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete TestSuiteStatic from TestSuiteStatic
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuiteStaticfromTestSuiteStatic0(
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .deleteTestSuiteStaticfromTestSuiteStatic0(testSuiteStaticId, contentType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Delete TestSuite from test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTestSuitefromtestsuites0(
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .deleteTestSuitefromtestsuites0(testSuiteStaticId, testSuiteStaticTestSuitesBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Retrieve TestCaseStatic from test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {string} [include] TestCaseStatic relationships to include (csv)
     * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterClassname] classname attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLine] line attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestCaseStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestCaseStaticfromtestcasestatics0(
      testSuiteStaticId: string,
      include?: string,
      fieldsTestCaseStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterName?: string,
      filterDescription?: string,
      filterClassname?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLine?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .retrieveTestCaseStaticfromtestcasestatics0(
          testSuiteStaticId,
          include,
          fieldsTestCaseStatic,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterName,
          filterDescription,
          filterClassname,
          filterGroup,
          filterFile,
          filterLine,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuiteStatic from TestSuiteStatic
     * @summary Retrieve a collection of TestSuiteStatic objects
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterName] name attribute filter (csv)
     * @param {string} [filterDescription] description attribute filter (csv)
     * @param {string} [filterPackage] package attribute filter (csv)
     * @param {string} [filterGroup] group attribute filter (csv)
     * @param {string} [filterFile] file attribute filter (csv)
     * @param {string} [filterLog] log attribute filter (csv)
     * @param {string} [filterVersion] version attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuiteStatic filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticinstance0(
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuiteStatic?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterName?: string,
      filterDescription?: string,
      filterPackage?: string,
      filterGroup?: string,
      filterFile?: string,
      filterLog?: string,
      filterVersion?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<TestSuiteStaticGetColl> {
      return TestSuiteStaticApiFp(configuration)
        .retrieveTestSuiteStaticinstance0(
          contentType,
          include,
          fieldsTestSuiteStatic,
          pageOffset,
          pageLimit,
          sort,
          filterName,
          filterDescription,
          filterPackage,
          filterGroup,
          filterFile,
          filterLog,
          filterVersion,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuiteStatic from TestSuiteStatic
     * @summary Retrieve TestSuiteStatic instance
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {string} [include] TestSuiteStatic relationships to include (csv)
     * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuiteStaticinstance1(
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      include?: string,
      fieldsTestSuiteStatic?: string,
      options?: any
    ): AxiosPromise<object> {
      return TestSuiteStaticApiFp(configuration)
        .retrieveTestSuiteStaticinstance1(testSuiteStaticId, contentType, include, fieldsTestSuiteStatic, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Retrieve TestSuite from test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {string} [include] TestSuite relationships to include (csv)
     * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
     * @param {number} [pageOffset] Page offset
     * @param {number} [pageLimit] Max number of items
     * @param {string} [sort] Sort order
     * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
     * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
     * @param {string} [filterTests] tests attribute filter (csv)
     * @param {string} [filterFailures] failures attribute filter (csv)
     * @param {string} [filterErrors] errors attribute filter (csv)
     * @param {string} [filterTime] time attribute filter (csv)
     * @param {string} [filterSkipped] skipped attribute filter (csv)
     * @param {string} [filterTimestamp] timestamp attribute filter (csv)
     * @param {string} [filterHostname] hostname attribute filter (csv)
     * @param {string} [filterUrl] url attribute filter (csv)
     * @param {string} [filterProperties] properties attribute filter (csv)
     * @param {string} [filterSystemOut] system_out attribute filter (csv)
     * @param {string} [filterSystemErr] system_err attribute filter (csv)
     * @param {string} [filterId] id attribute filter (csv)
     * @param {string} [filter] Custom TestSuite filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveTestSuitefromtestsuites0(
      testSuiteStaticId: string,
      include?: string,
      fieldsTestSuite?: string,
      pageOffset?: number,
      pageLimit?: number,
      sort?: string,
      filterTestSuiteStaticId?: string,
      filterTestRunId?: string,
      filterTests?: string,
      filterFailures?: string,
      filterErrors?: string,
      filterTime?: string,
      filterSkipped?: string,
      filterTimestamp?: string,
      filterHostname?: string,
      filterUrl?: string,
      filterProperties?: string,
      filterSystemOut?: string,
      filterSystemErr?: string,
      filterId?: string,
      filter?: string,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .retrieveTestSuitefromtestsuites0(
          testSuiteStaticId,
          include,
          fieldsTestSuite,
          pageOffset,
          pageLimit,
          sort,
          filterTestSuiteStaticId,
          filterTestRunId,
          filterTests,
          filterFailures,
          filterErrors,
          filterTime,
          filterSkipped,
          filterTimestamp,
          filterHostname,
          filterUrl,
          filterProperties,
          filterSystemOut,
          filterSystemErr,
          filterId,
          filter,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update TestSuiteStatic attributes
     * @summary Update TestSuiteStatic
     * @param {string} testSuiteStaticId
     * @param {'application/vnd.api+json' | 'application/json'} contentType
     * @param {TestSuiteStaticPatchInst} pATCHBody TestSuiteStatic attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestSuiteStatic0(
      testSuiteStaticId: string,
      contentType: 'application/vnd.api+json' | 'application/json',
      pATCHBody: TestSuiteStaticPatchInst,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .updateTestSuiteStatic0(testSuiteStaticId, contentType, pATCHBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestSuiteStatic test_case_statics \"to-many\" relationship
     * @summary Update test_case_statics
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestCaseStaticsRelationship} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestcasestatics0(
      testSuiteStaticId: string,
      testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .updatetestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the TestSuiteStatic test_suites \"to-many\" relationship
     * @summary Update test_suites
     * @param {string} testSuiteStaticId TestSuiteStatic item
     * @param {TestSuiteStaticTestSuitesRelationship} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatetestsuites0(
      testSuiteStaticId: string,
      testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship,
      options?: any
    ): AxiosPromise<void> {
      return TestSuiteStaticApiFp(configuration)
        .updatetestsuites0(testSuiteStaticId, testSuiteStaticTestSuitesBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TestSuiteStaticApi - object-oriented interface
 * @export
 * @class TestSuiteStaticApi
 * @extends {BaseAPI}
 */
export class TestSuiteStaticApi extends BaseAPI {
  /**
   * Add TestCaseStatic items to the TestSuiteStatic test_case_statics \"to-many\" relationship
   * @summary Add TestCaseStatic items to test_case_statics
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public addTestCaseStaticitemstotestcasestatics0(
    testSuiteStaticId: string,
    testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .addTestCaseStaticitemstotestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Add TestSuite items to the TestSuiteStatic test_suites \"to-many\" relationship
   * @summary Add TestSuite items to test_suites
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public addTestSuiteitemstotestsuites0(
    testSuiteStaticId: string,
    testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .addTestSuiteitemstotestsuites0(testSuiteStaticId, testSuiteStaticTestSuitesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create TestSuiteStatic
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestSuiteStaticPostInst1} pOSTBody TestSuiteStatic attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public createTestSuiteStatic0(
    contentType: 'application/vnd.api+json' | 'application/json',
    pOSTBody: TestSuiteStaticPostInst1,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .createTestSuiteStatic0(contentType, pOSTBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
   * @summary Delete TestCaseStatic from test_case_statics
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {TestSuiteStaticTestCaseStaticsRelationship1} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public deleteTestCaseStaticfromtestcasestatics0(
    testSuiteStaticId: string,
    testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship1,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .deleteTestCaseStaticfromtestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete TestSuiteStatic from TestSuiteStatic
   * @param {string} testSuiteStaticId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public deleteTestSuiteStaticfromTestSuiteStatic0(
    testSuiteStaticId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .deleteTestSuiteStaticfromTestSuiteStatic0(testSuiteStaticId, contentType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
   * @summary Delete TestSuite from test_suites
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {TestSuiteStaticTestSuitesRelationship1} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public deleteTestSuitefromtestsuites0(
    testSuiteStaticId: string,
    testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship1,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .deleteTestSuitefromtestsuites0(testSuiteStaticId, testSuiteStaticTestSuitesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestCaseStatic items from the TestSuiteStatic test_case_statics \"to-many\" relationship
   * @summary Retrieve TestCaseStatic from test_case_statics
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {string} [include] TestCaseStatic relationships to include (csv)
   * @param {string} [fieldsTestCaseStatic] TestCaseStatic fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterDescription] description attribute filter (csv)
   * @param {string} [filterClassname] classname attribute filter (csv)
   * @param {string} [filterGroup] group attribute filter (csv)
   * @param {string} [filterFile] file attribute filter (csv)
   * @param {string} [filterLine] line attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestCaseStatic filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public retrieveTestCaseStaticfromtestcasestatics0(
    testSuiteStaticId: string,
    include?: string,
    fieldsTestCaseStatic?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterName?: string,
    filterDescription?: string,
    filterClassname?: string,
    filterGroup?: string,
    filterFile?: string,
    filterLine?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .retrieveTestCaseStaticfromtestcasestatics0(
        testSuiteStaticId,
        include,
        fieldsTestCaseStatic,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterName,
        filterDescription,
        filterClassname,
        filterGroup,
        filterFile,
        filterLine,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuiteStatic from TestSuiteStatic
   * @summary Retrieve a collection of TestSuiteStatic objects
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestSuiteStatic relationships to include (csv)
   * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterName] name attribute filter (csv)
   * @param {string} [filterDescription] description attribute filter (csv)
   * @param {string} [filterPackage] package attribute filter (csv)
   * @param {string} [filterGroup] group attribute filter (csv)
   * @param {string} [filterFile] file attribute filter (csv)
   * @param {string} [filterLog] log attribute filter (csv)
   * @param {string} [filterVersion] version attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuiteStatic filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public retrieveTestSuiteStaticinstance0(
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestSuiteStatic?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterName?: string,
    filterDescription?: string,
    filterPackage?: string,
    filterGroup?: string,
    filterFile?: string,
    filterLog?: string,
    filterVersion?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .retrieveTestSuiteStaticinstance0(
        contentType,
        include,
        fieldsTestSuiteStatic,
        pageOffset,
        pageLimit,
        sort,
        filterName,
        filterDescription,
        filterPackage,
        filterGroup,
        filterFile,
        filterLog,
        filterVersion,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuiteStatic from TestSuiteStatic
   * @summary Retrieve TestSuiteStatic instance
   * @param {string} testSuiteStaticId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {string} [include] TestSuiteStatic relationships to include (csv)
   * @param {string} [fieldsTestSuiteStatic] TestSuiteStatic fields to include (csv)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public retrieveTestSuiteStaticinstance1(
    testSuiteStaticId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    include?: string,
    fieldsTestSuiteStatic?: string,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .retrieveTestSuiteStaticinstance1(testSuiteStaticId, contentType, include, fieldsTestSuiteStatic, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve TestSuite items from the TestSuiteStatic test_suites \"to-many\" relationship
   * @summary Retrieve TestSuite from test_suites
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {string} [include] TestSuite relationships to include (csv)
   * @param {string} [fieldsTestSuite] TestSuite fields to include (csv)
   * @param {number} [pageOffset] Page offset
   * @param {number} [pageLimit] Max number of items
   * @param {string} [sort] Sort order
   * @param {string} [filterTestSuiteStaticId] test_suite_static_id attribute filter (csv)
   * @param {string} [filterTestRunId] test_run_id attribute filter (csv)
   * @param {string} [filterTests] tests attribute filter (csv)
   * @param {string} [filterFailures] failures attribute filter (csv)
   * @param {string} [filterErrors] errors attribute filter (csv)
   * @param {string} [filterTime] time attribute filter (csv)
   * @param {string} [filterSkipped] skipped attribute filter (csv)
   * @param {string} [filterTimestamp] timestamp attribute filter (csv)
   * @param {string} [filterHostname] hostname attribute filter (csv)
   * @param {string} [filterUrl] url attribute filter (csv)
   * @param {string} [filterProperties] properties attribute filter (csv)
   * @param {string} [filterSystemOut] system_out attribute filter (csv)
   * @param {string} [filterSystemErr] system_err attribute filter (csv)
   * @param {string} [filterId] id attribute filter (csv)
   * @param {string} [filter] Custom TestSuite filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public retrieveTestSuitefromtestsuites0(
    testSuiteStaticId: string,
    include?: string,
    fieldsTestSuite?: string,
    pageOffset?: number,
    pageLimit?: number,
    sort?: string,
    filterTestSuiteStaticId?: string,
    filterTestRunId?: string,
    filterTests?: string,
    filterFailures?: string,
    filterErrors?: string,
    filterTime?: string,
    filterSkipped?: string,
    filterTimestamp?: string,
    filterHostname?: string,
    filterUrl?: string,
    filterProperties?: string,
    filterSystemOut?: string,
    filterSystemErr?: string,
    filterId?: string,
    filter?: string,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .retrieveTestSuitefromtestsuites0(
        testSuiteStaticId,
        include,
        fieldsTestSuite,
        pageOffset,
        pageLimit,
        sort,
        filterTestSuiteStaticId,
        filterTestRunId,
        filterTests,
        filterFailures,
        filterErrors,
        filterTime,
        filterSkipped,
        filterTimestamp,
        filterHostname,
        filterUrl,
        filterProperties,
        filterSystemOut,
        filterSystemErr,
        filterId,
        filter,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update TestSuiteStatic attributes
   * @summary Update TestSuiteStatic
   * @param {string} testSuiteStaticId
   * @param {'application/vnd.api+json' | 'application/json'} contentType
   * @param {TestSuiteStaticPatchInst} pATCHBody TestSuiteStatic attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public updateTestSuiteStatic0(
    testSuiteStaticId: string,
    contentType: 'application/vnd.api+json' | 'application/json',
    pATCHBody: TestSuiteStaticPatchInst,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .updateTestSuiteStatic0(testSuiteStaticId, contentType, pATCHBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestSuiteStatic test_case_statics \"to-many\" relationship
   * @summary Update test_case_statics
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {TestSuiteStaticTestCaseStaticsRelationship} testSuiteStaticTestCaseStaticsBody TestSuiteStatic.test_case_statics POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public updatetestcasestatics0(
    testSuiteStaticId: string,
    testSuiteStaticTestCaseStaticsBody: TestSuiteStaticTestCaseStaticsRelationship,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .updatetestcasestatics0(testSuiteStaticId, testSuiteStaticTestCaseStaticsBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the TestSuiteStatic test_suites \"to-many\" relationship
   * @summary Update test_suites
   * @param {string} testSuiteStaticId TestSuiteStatic item
   * @param {TestSuiteStaticTestSuitesRelationship} testSuiteStaticTestSuitesBody TestSuiteStatic.test_suites POST model
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuiteStaticApi
   */
  public updatetestsuites0(
    testSuiteStaticId: string,
    testSuiteStaticTestSuitesBody: TestSuiteStaticTestSuitesRelationship,
    options?: any
  ) {
    return TestSuiteStaticApiFp(this.configuration)
      .updatetestsuites0(testSuiteStaticId, testSuiteStaticTestSuitesBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
